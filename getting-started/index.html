<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <title>Crails Framework - Getting Started with Crails Framework</title>
    <link rel="stylesheet" href="../css/application.css">
    <link rel="stylesheet" href="../css/code-qtcreator.css">
    <script src="../highlight.pack.js"></script>
    <script src="../js/index.js"></script>

    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="Nanoc 4.12.11">
  </head>
  <body>
    <div id="header">
      <img class="logo" src="../images/logo.png">
      <h1>Crails Framework</h1>
      <ul class="main-menu">
        <li><a href="../">Home</a></li><li>
            <a href=".">Getting started</a></li><li>
            <a href="../tutorials">Tutorials</a></li><li>
	    <a href="https://github.com/crails-framework/crails" target="_blank">GitHub</a></li>
      </ul>
    </div>
    <div id="content-wrapper">
      <div id="main">
        <div id="with-index"></div>

<h2>1. Guide Assumptions</h2>
<p>
  This guide is designed for beginners who want to get started with Crails from scratch. It does not assume any prior experience with Crails.
</p>

<p>
  We assume you are already familiar with the C++ programming language and CMake building tools.
</p>

<h2>2. Creating a new Crails Application</h2>
<p>
  The best way to read this guide is to follow it step by step. All steps are essential to run this example application and no additional code or steps are needed.
</p>

<p>
  By following this guide, you'll create a very simple weblog.
</p>

<h3>2.1 Installing Crails</h3>
<p>
  First, if you haven't already done it before, you need to install Crails Framework.
  You may do so by following the guide corresponding to your operating system:
</p>
<ul>
  <li><a href="linux.html" target="_blank">Linux, FreeBSD, MacOS</a></li>
</ul>

<h3>2.2 Creating the Blog application</h3>
<p>
  Crails comes with a application generator tool which will provide you the foundation of a fresh Crails application, so that you don't have to write it yourself.
</p>

<p>
  To use this generator, open a terminal, navigate to the directory in which you wish to create the application, and type:
</p>

<pre>$ crails new --name blog</pre>

<p>
  This will create a Crails application called Blog in a `blog` directory.
</p>

<div class="hint-box">
  Take some time to check out the configuration options provided by running <code>crails new -h</code>.
</div>

<p>
  After you create the blog application, switch to its folder:
</p>

<pre>$ cd blog</pre>

<p>
  The <code>blog</code> directory has a number of auto-generated files and folders that make up the structure of a Crails application. Most of the work in this tutorial will happen in the <code>app</code> folder, but here's a basic rundown on the function of each file and folders that Crails created by default:
</p>

<table>
  <tbody><tr>
    <th>File/Folder</th>
    <th>Purpose</th>
  </tr>
  <tr>
    <td>app/</td>
    <td>Contains the controllers, models, views, helpers, mailers and assets for your application.</td>
  </tr>
  <tr>
    <td>app/main.cpp</td>
    <td>This file contains the entry point for the server binary.</td>
  </tr>
  <tr>
    <td>app/routes.cpp</td>
    <td>This is where you'll bind your routes with your controller methods.</td>
  </tr>
  <tr>
    <td>build/</td>
    <td>Output for your application binaires: server, tasks, anything from your application that can be executed will end up in this folder.</td>
  </tr>
  <tr>
    <td>config/</td>
    <td>Configure your application's database, <a href="../request_pipeline">request pipeline</a> and several optional features of Crails.</td>
  </tr>
  <tr>
    <td>lib/</td>
    <td>This folder is used for application code that you haven't written yourself. Crails uses several code generating utilities: the <code>lib</code> folder is where this code will be generated and compiled from</td>
  </tr>
  <tr>
    <td>public/</td>
    <td>The only folder seen by the world as-is. Contains static files and compiled assets.</td>
  </tr>
  <tr>
    <td>spec/</td>
    <td>This is where you'll write tests for your application.</td>
  </tr>
  <tr>
    <td>CMakeLists.txt</td>
    <td>Contains a set of directives describing the project's source files, dependencies, and build targets.</td>
  </tr>
  <tr>
    <td>.crails</td>
    <td>This file is managed by the command line interface tool, and records several settings about your project used when building or generating code.</td>
  </tr>
</tbody></table>

<h2>3. Hello, Crails!</h2>
<p>
  To begin with, let's get some text up on screen quickly. Let's get your Crails application running:
</p>

<h3>3.1 Starting up the web server</h3>
<pre><code>$ crails build
$ build/server</code></pre>

<p>
  The first command will compile your application. The second one
  will fire up your server binary. To see your application in action, open a browser window and navigate to <a href="http://localhost:3000" target="_blank">http://localhost:3000</a>. You should see the Crails default information page:
</p>

<img src="../images/crails-welcome-page-screenshot.png">

<div class="hint-box">
  To stop the web server, hit Ctrl+C in the terminal window where it's running. To verify the server has stopped you should see your command prompt cursor again. Note that changes you make to your application's code won't get picked up by the server unless you run a new compilation using <code>crails build</code> and then restart the server.
</div>

<p>
  The Crails default information page is the smoke test for a new Crails application: it makes sure that your application is configured correctly and can receive and respond to http queries.
</p>

<h3>3.2 Say "Hello", Crails</h3>

<p>
  To get Crails to say "Hello", you need to create at minimum a <i>route</i>, a <i>controller</i> and a <i>view</i>. A route maps a request to a controller action. A controller action performs the necessary work to handle the request, and prepares any data for the view. A view displays data in the desired format.
</p>

<p>
  To create a new controller, we'll run the controller generator:
</p>

<pre>$ crails scaffold controller -n Welcome</pre>

<p>
  This will generate two files: <code>app/controllers/welcome.hpp</code> and <code>app/controllers/welcome.cpp</code>. Let's take a look at those:
</p>

<pre class="filepath">app/controllers/welcome.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include "app/controllers/application.hpp"

class WelcomeController : public ApplicationController
{
public:
  WelcomeController(Crails::Context&amp; context);

  void initialize() override;
  void finalize() override;
};
</code></pre>

<pre class="filepath">app/controllers/welcome.cpp</pre>
<pre><code class="language-cpp">#include "welcome.hpp"

using namespace std;

WelcomeController::WelcomeController(Crails::Context&amp; context)
  : ApplicationController(context)
{
}

void WelcomeController::initialize()
{
  ApplicationController::initialize();
}

void WelcomeController::finalize()
{
  ApplicationController::finalize();
}
</code></pre>

<p>
  This is a basic skeleton for a controller. We will now add an <code>action</code> to the controller by adding the <code>index</code> method:
</p>

<pre class="filepath">app/controllers/welcome.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include "app/controllers/application.hpp"

class WelcomeController : public ApplicationController
{
public:
  WelcomeController(Crails::Context&amp; context);

  void initialize() override;
  void finalize() override;

  void index()
  {
    render(TEXT, "Hello world!"); // will respond to the action
                                  // with a plain text answer
  }
};
</code></pre>

<p>
  Then, you need to register a new route in <code>app/routes.cpp</code>:
</p>

<pre class="filepath">app/routes.cpp</pre>
<pre><code class="language-cpp">#include &lt;crails/router.hpp&gt;
#include "controllers/welcome.hpp"

void Crails::Router::initialize()
{
  match_action("GET", "/", WelcomeController, index);
}
</code></pre>

<div class="hint-box">
  For more information about routing, refer to the <a href="../tutorials/routing">Crails Routing guide</a>
</div>

<p>
  Lastly, remove the default <code>index.html</code> file (otherwise, it will be served by default as the root of your application)
</p>

<pre><code>$ rm public/index.tml</code></pre>

<p>
  We're good to go. Compile your code and restart the server to get it to pick up your changes:
</p>

<pre><code>$ crails build
$ build/server</code></pre>

<p>
  Then, open <a href="http://localhost:3000" target="_blank">http://localhost:3000</a> in a web browser. You'll see a simple text response saying "Hello world!".
</p>

<h3>3.3 Say "Hello" with HTML</h3>

<p>
  In the last section, our server gave a response using the <code>text/plain</code> format. To provide an HTML response, you'll need to create a view.
</p>

<p>
  A view's purpose is to display information in a human readable format. An important distinction to make is that it is the <i>controller</i>, not the view, where information is collected. The view should just display that information. By default, view templates are written in a language called ecpp (Embedded C++) which is used to generate the C++ code for your views.
</p>

<p>
  First, you need to enable html views in your application. To do that, you need to add the <code>html</code> renderer to your application, by running the following command:
</p>

<pre><code>$ crails templates formats --add html</code></pre>

<p>
  Now, we'll add a new folder at <code>app/views/welcome</code> to create an ecpp template named <code>app/views/welcome/index.html</code>
</p>

<pre class="filepath">app/views/welcome/index.html</pre>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello world!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    This view has been generated from an ecpp template.
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p style="text-align: left">
  We also need to update our controller so that it responds using our view:
</p>

<pre class="filepath">app/controllers/welcome.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include "app/controllers/application.hpp"

class WelcomeController : public ApplicationController
{
public:
  WelcomeController(Crails::Context&amp; context);

  void initialize() override;
  void finalize() override;

  void index()
  {
    render("welcome/index"); // &lt;-- renders the html view
  }
};
</code></pre>

<p>
  Compile and restart your server, then go to <a href="http://localhost:3000" target="_blank">http://localhost:3000</a> to see that your application now provides an HTML response.
</p>

<h2>4. Getting Up and Running</h2>

<p>
  Now that you've seen how to create a controller, an action, and a view, let's create something with a bit more substance.
</p>

<p>
  In the Blog application, you will now create a new resource. A resource is the term used for a collection of similar objects, such as articles, people, or animals. You can create, read, update, and destroy items for a resource and these operations are referred to as CRUD operations.
</p>

<h3>4.1 Setting up a database</h3>

<p>
  Resources need to be persistent, and for that, we will be using an SQL database. The preferred method for that is to use the <a href="https://www.codesynthesis.com/products/odb/" target="_blank">ODB ORM</a>. We provide a plugin to integrate it with our controller and building system. Let's install it:
</p>

<pre>$ crails plugins odb install -b sqlite</pre>

<p>
  This will update your CMakeLists.txt to link your application to the odb libraries, generate a default configuration for an <i>sqlite</i> database, and adds the odb_migrate task which we'll describe later on.
</p>

<div class="hint-box">
  Check out the <a href="#">Crails Databases manual</a> to learn more about the configuration options for databases with crails.
</div>

<h3>4.2 Creating an MVC resource</h3>

<p>
  Now that our database is configured, we will create a set of model, views and controllers. To generate it
  all at once, we will use the resource generator:
</p>

<pre>$ crails scaffold resource -m Article -p std::string/title std::string/content</pre>

<p>
This will create the following files:
</p>

<table>
  <tbody><tr>
    <th>File</th>
    <th>Purpose</th>
  </tr>
  <tr>
    <td>app/models/article.hpp</td>
    <td>odb-based model</td>
  </tr>
  <tr>
    <td>app/models/article.cpp</td>
    <td>model implementation</td>
  </tr>
  <tr>
    <td>app/controllers/article.hpp</td>
    <td>odb-based controller with CRUD actions</td>
  </tr>
  <tr>
    <td>app/controllers/article.cpp</td>
    <td>controller implementation</td>
  </tr>
  <tr>
    <td>app/views/article/index.html</td>
    <td>lists an index of article loaded by the controller</td>
  </tr>
  <tr>
    <td>app/views/article/show.html</td>
    <td>shows a single article loaded by the controller</td>
  </tr>
  <tr>
    <td>app/views/article/new.html</td>
    <td>displays a form to create a new article</td>
  </tr>
  <tr>
    <td>app/views/article/edit.html</td>
    <td>displays a form to edit an existing article</td>
  </tr>
  <tr>
    <td>app/views/article/form.html</td>
    <td><a href="../tutorials/layouts#partial-rendering">partial view</a> containing the form used in the <i>new</i> and <i>edit</i> views.</td>
  </tr>
</tbody></table>

<p>
  The <code>app/routes.cpp</code> file will also be modified to connect our controller's actions:
</p>

<pre class="filepath">app/routes.cpp</pre>
<pre><code class="language-cpp">#include "app/controllers/article.hpp"
#include "app/controllers/welcome.hpp"
#include &lt;crails/router.hpp&gt;

void Crails::Router::initialize()
{
  resource_actions(article, ArticleController);
  match_action("GET", "/", WelcomeController, index);
}
</code></pre>

<p>
  The <code>resource_actions</code> macro creates routes for all the actions in our resource controller. You can learn more about the <code>resource_actions</code> macro in the <a href="../tutorials/routing#resource_actions">Routing guide</a>.
</p>

<h3>4.3 Database Migrations</h3>

<p>
  <i>Migrations</i> are used to alter the structure of an application's database. In Crails applications,
  migrations are written in XML and C++ so they can be database agnostic.
</p>

<div class="hint-box">
  In the simplest scenarios, the <i>odb</i> compiler generates an <i>application.xml</i> file that tracks
  changes to the database schema. In most cases, this is enough to handle updates to your databases, though
  you can also run C++ code between migrations (for instance, when you need to change the content of a
  column during a migration). Check that out in the <a href="../tutorials/odb_migrations">Migrations with ODB</a> manual.
</div>

<p>
  To create or update a database table schema, we will have to use the <i>odb_migrate</i> task:
</p>

<pre>$ crails build # don't forget to build your project first
$ build/tasks/odb_migrate/task -c odb</pre>

<p>
  The <i>-c</i> option tells the migrating task to create the database if it does not already exist.
</p>

<p>
  The <i>odb</i> parameter points to a specific database configured in our project, which you can find in
  the <code>config/databases.cpp</code> file which was generated when we installed the odb plugin.
</p>

<h3>4.4 Showing a list of Articles</h3>

<p>
  Let's take a look at the controller we just generated, at <code>app/controllers/article.cpp</code>.
  The generator defined two methods used to show an index of article: the <code>find_list</code> and
  <code>index</code> methods:
</p>

<pre class="filepath">app/controllers/article.cpp</pre>
<pre><code class="language-cpp">void ArticleController::find_list()
{
  odb::result&lt;Article&gt; results;

  database.find(results);
  model_list = Crails::Odb::to_vector&lt;Article&gt;(results);
  vars["models"] = &amp;model_list;
}

void ArticleController::index()
{
  find_list();
  render("article/index");
}
</code></pre>

<p>
  The <code>find_list</code> method fetches all the Article objects stored in database, and store the
  results in <code>model_list</code>, which is a container declared in our generated controller.
</p>

<p>
  Notice the <code>vars["models"] = &amp;model_list</code> assignation. The <code>vars</code> object
  is used to share variables with views. We'll now take a look at the <i>index</i> view and see how
  to read the contents of this variable.
</p>

<p>
  Open the <code>app/views/article/index.html</code> file, and replace its contents as following:
</p>

<pre class="filepath">app/views/welcome/index.html</pre>
<pre><code class="language-html">#include "app/models/article.hpp"

std::vector&lt;Article&gt;&amp; @models;
// END LINKING
&lt;h1&gt;Article index&lt;/h1&gt;

&lt;ul&gt;
  &lt;% for (const Article&amp; article : models) do %&gt;
    &lt;li&gt;
      &lt;%= article.get_name() %&gt;
    &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>
  The above code is a mixture of HTML and <i>ECPP</i>. ECPP is a templating system that generates C++
  from markup documents. Here, we can see two types of ECPP tags: <code>&lt;% %&gt;</code> and
  <code>&lt;%= %&gt;</code>. The <code>&lt;% %&gt;</code> tag means "evaluate the enclosed C++ code".
  The <code>&lt;%= %&gt;</code> means "evaluate the enclosed C++ code, and output the value it returns".
  Anything you could write in the body of a C++ function can go inside these ECPP tags, though it's
  usually best to keep the contents of ERB tags short, for readability.
</p>

<div class="hint-box">
  ECPP is based on <code>std::stringstream</code>, which means the <code>&lt;%= %&gt;</code> tags can
  output anything supported by a <code>std::stringstream</code>.
</div>

<p>
  We can see the final result by visiting <a href="http://localhost:3000/article">http://localhost:3000/article</a>.
  (Remember that <code>build/server</code> server must be running!) Here's what happens when we do that:
</p>

<p>
  1. The browser makes a request <code>GET http://localhost:3000/article</code><br>
  2. Our Crails application receive the request<br>
  3. The Crails router maps the article route to the <i>index</i> action of <code>ArticleController</code><br>
  4. The <i>find_list</i> method uses the <code>Article</code> model and the <code>database</code> object to fetch all articles from the database.<br>
  5. The <i>index</i> action renders the <i>app/views/article/index.html</i> view.<br>
  6. The ECPP template is evaluated and outputs HTML.<br>
  7. The server sends a repsonse containing the HTML back to the browser.
</p>

<p>
  We've connected all the MVC pieces together, and we have our first controller action! Next, we'll move on to the second action.
</p>

<h2>5. CRUDit where CRUDit is due</h2>

<p>
  Almost all web applications involve <a href="https://en.wikipedia.org/wiki/Create,_read,_update,_and_delete">CRUD (Create, Read, Update, and Delete)</a> operations. You may even find that the majority of the work your application does is CRUD. Crails acknowledges this, and provides many features to help simplify code doing CRUD.
</p>

<p>
  Let's begin exploring these features by adding more functionality to our application.
</p>

<h3>5.1 Showing a Single Article</h3>

<p>
  We currently have a view that lists all articles in our database. Let's add a new view that shows the title and body of a single article.
</p>

<p>
  The resource generator we used earlier already generated the route and controller methods needed. Let's take
  a look at the controller's code:
</p>

<pre class="filepath">app/controllers/article.cpp</pre>
<pre><code class="language-cpp">std::shared_ptr&lt;Article&gt; ArticleController::find_model(Crails::Odb::id_type id)
{
  database.find_one(model, odb::query&lt;Article&gt;::id == id);
  vars["model"] = model.get();
  return model;
}

void ArticleController::require_model(Crails::Odb::id_type id)
{
  if (!model &amp;&amp; !find_model(id))
    respond_with(Crails::HttpStatus::not_found);
}

void ArticleController::show()
{
  render("article/show");
}
</code></pre>

<p>
  Three methods are involved in showing a single article:
  </p><ul>
    <li>
      <i>find_model</i> should look familiar. Instead of fetching a list of articles, it fetches a single
      article, looking up for its ID. It then stores a pointer to the article object in the <code>vars</code> object.
    </li>
    <li>
      <i>require_model</i> calls <i>find_model</i>, and uses <i>respond_with</i> to respond with <i>404 not found</i>
      when no model were found.
    </li>
    <li>
      <i>show</i> renders the <i>app/views/article/show.html</i> view.
    </li>
  </ul>
<p></p>

<p>
  You might've noticed that the <i>require_model</i> method isn't being called by the <i>show</i> action. In
  simple cases, you may want to fetch the model directly from the action. But since multiple actions will need
  to fetch a model, we'll use the <i>initialize</i> method instead.
</p>

<h4 id="initialize-finalize">5.1.1 Initialize and finalize</h4>

<p>
  Before and after running each action on a controller, the <code>initialize</code> and <code>finalize</code> methods
  will be called. This can be useful when several actions need to be setup in similar ways.
</p>

<p>
  Let's take a look at the <code>initialize</code> method generated for our <code>ArticleController</code>:
</p>

<pre class="filepath">app/controllers/article.cpp</pre>
<pre><code class="language-cpp">void ArticleController::initialize()
{
  Crails::Odb::Controller&lt;ApplicationController&gt;::initialize();
  string action_name = get_action_name();

  if (action_name == "show" || action_name == "edit" || action_name == "update" || action_name == "destroy")
    require_model(params["id"]);
}
</code></pre>

<p>
  In this initializer, we use <code>get_action_name</code> to figure out which action is about to be triggered.
  If said action requires a single article model to be loaded, we call <code>require_model</code>.
</p>

<div class="hint-box">
  When a request's response is provided within an initializer, the <i>action</i> method won't be called at all.
  The <i>finalize</i> method, however, is always called.
</div>

<p>
  As we've seen earlier, the <code>require_model</code> method already provides a response by calling
  <code>respond_with</code> when the resource was not found. In such cases, the <code>show</code> method will
  only be called when an Article object is loaded within the shared variable object (<code>vars</code>).
</p>

<h4>5.1.2 Setting up the show view</h4>

<p>
  Let's create our show view by replacing the content of <code>app/views/article/show.html</code> with the
  following contents:
</p>

<pre class="filepath">app/views/article/show.html</pre>
<pre><code class="language-html">#include "app/models/article.hpp"
Article&amp; @model;
// END LINKING
&lt;h1&gt;&lt;%= model.get_title() %&gt;&lt;/h1&gt;

&lt;p&gt;&lt;%= model.get_content() %&gt;&lt;/p&gt;
</code></pre>

<p>
  Now we can see the article when we visit <a href="http://localhost:3000/article/1">http://localhost:3000/article/1</a>!
</p>

<p>
  To finish up, let's add a convenient way to get to an article's page. We'll link each article's title in the index view to its page:
</p>

<pre class="filepath">app/views/article/index.html</pre>
<pre><code class="language-html">#include "app/models/article.hpp"

std::vector&lt;Article&gt;&amp; @models;
// END LINKING
&lt;h1&gt;Article index&lt;/h1&gt;

&lt;ul&gt;
  &lt;% for (const Article&amp; article : models) do %&gt;
    &lt;li&gt;
      &lt;a href="/article/&lt;%= article.get_id() %&gt;"&gt;
        &lt;%= article.get_name() %&gt;
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<h3>5.2 Creating a New Article</h3>

<p>
  Now we move on to the "C" (Create) of CRUD. Typically, in web applications, creating a new resource is a multi-step process. First, the user requests a form to fill out. Then, the user submits the form. If there are no errors, then the resource is created and some kind of confirmation is displayed. Else, the form is redisplayed with error messages, and the process is repeated.
</p>

<p>
  In a Rails application, these steps are conventionally handled by a controller's <code>new_</code> and <code>create</code> actions. Let's check out the implementation of these actions in our generated controller:
</p>

<pre class="filepath">app/controllers/articles.cpp</pre>
<pre><code class="language-cpp">void ArticleController::new_()
{
  render("article/new");
}

void ArticleController::create()
{
  Article model;
  model.edit(params[Article::resource_name]);
  database.save(model);
  redirect_to("/article/" + boost::lexical_cast&lt;std::string&gt;(model.get_id()));
}
</code></pre>

<p>
  The <code>new</code> action is very simple, and merely renders the <code>app/views/article/new.html</code> view.
</p>

<p>
  The <code>create</code> action instantiates a new article, and initialize its properties from parameters using
  <code>model.edit(params[Article::resource_name])</code>. It then persists the model to database by calling <code>database.save(model)</code>. At this point, the model should have an ID assigned to it: we use this ID to respond with a 303
  redirection, by calling <code>redirect_to</code> towards the <i>show</i> route for the article model.
</p>

<h4>5.2.1 New view</h4>

<p>
  Let's take a look at the <code>app/views/article/new.html</code> view that was generated with the <code>crails scaffold resource</code> command:
</p>

<pre class="filepath">app/views/article/new.html</pre>
<pre><code class="language-html">#include "app/models/article.hpp"
Article model;
// END LINKING
&lt;h1&gt;New Article&lt;/h1&gt;
&lt;%= partial("article/form", {{"model", &amp;model}} %&gt;
</code></pre>

<p>
  The <code>new.html</code> view is very simple: it instantiate an empty Article, then renders a <i>partial view</i>
  that contains the form for our article model. Using a partial for the form allows us to use the same HTML for
  both the creation and updating forms. Let's head over to the form partial to see what's going on there.
</p>

<div class="hint-box">You can read more about partials in the <a href="../tutorials/layouts#partial-rendering">crails-html layout and rendering</a> guide.</div>

<h4>5.2.2 Using a form builder</h4>

<p>
  We will use a feature of Rails called a form builder to create our form. Using a form builder, we can write a minimal amount of code to output a form that is fully configured and follows Crails conventions.
</p>

<p>
  Let's replace the contents of <code>app/views/article/form.html</code> with the following:
</p>

<pre class="filepath">app/views/article/form.html</pre>
<pre><code class="language-html">#include "app/models/article.hpp"
#include &lt;crails/html_form_builder.hpp&gt;

Article&amp; @model;
Crails::FormBuilder&lt;Article&gt; form = Crails::FormBuilder&lt;Article&gt;(this, model);
// END LINKING
&lt;%= form_for(model, "/article") yields %&gt;
  &lt;div&gt;
    &lt;%= form.label_for("title") %&gt;
    &lt;%= form.text_field("title", &amp;Article::get_title) %&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;%= form.label_for("content") %&gt;
    &lt;%= form.text_area("content", &amp;Article::get_content) %&gt;
  &lt;/div&gt;
&lt;% yields-end %&gt;
</code></pre>

<p>
  The <code>form_for</code> creates a &lt;form&gt; tag with the proper action and method attributes.
  It also includes the CSRF token for the query (<a href="../about-csrf">About CSRF</a>).
</p>

<p>
  Then, we use the <code>Crails::FormBuilder</code> template class and call methods like <code>label_for</code>
  and <code>text_field</code> to output the appropriate form elements.
</p>

<p>
  The resulting output from out <code>form_for</code> call will look like:
</p>

<pre><code class="language-html">&lt;form action="/article" method="post"&gt;
  &lt;input type="csrf-token" value="..."&gt;
  &lt;div&gt;
    &lt;label for="article[title]"&gt;title&lt;/label&gt;
    &lt;input type="text" name="article[title]"&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for="article[content]"&gt;content&lt;/label&gt;
    &lt;textarea name="article[content]"&gt;&lt;/textarea&gt;
  &lt;/div&gt;
&lt;/form&gt;
</code></pre>

<div class="hint-box">
  To learn more about form builders, see <a href="../tutorials/form-builder">Html form helpers</a>.
</div>

<h4>5.2.3 Finishing up</h4>

<p>
  We can now create an article by visiting <a href="http://localhost:3000/article/new">http://localhost:3000/article/new</a>. To finish up, let's link to that page from the bottom of the article index:
</p>

<pre class="filepath">app/views/article/index.html</pre>
<pre><code class="language-html">#include "app/models/article.hpp"

std::vector&lt;Article&gt;&amp; @models;
// END LINKING
&lt;h1&gt;Article index&lt;/h1&gt;

&lt;ul&gt;
  &lt;% for (const Article&amp; article : models) do %&gt;
    &lt;li&gt;
      &lt;%= article.get_name() %&gt;
    &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;

&lt;a href="/article/new"&gt;New Article&lt;/a&gt;
</code></pre>

<h3>5.3 Updating an Article</h3>

<p>
  We've covered the "CR" of CRUD. Now let's move on to the "U" (Update). Updating a resource is very similar to creating a resource. They are both multi-step processes. First, the user requests a form to edit the data. Then, the user submits the form. If there are no errors, then the resource is updated. Else, the form is redisplayed with error messages, and the process is repeated.
</p>

<p>
  These steps are conventionally handled by a controller's <code>edit</code> and <code>update</code> actions. Let's take a look at the implementation of these actions that was generated by our <i>scaffold</i>, below the create action:
</p>

<pre class="filepath">app/controllers/article.cpp</pre>
<pre><code class="language-cpp">void ArticleController::edit()
{
  render("article/edit");
}

void ArticleController::update()
{
  model-&gt;edit(params[Article::resource_name]);
  database.save(*model);
  redirect_to("article/" + boost::lexical_cast&lt;std::string&gt;(model-&gt;get_id()));
}
</code></pre>

<p>
  Notice how the <code>edit</code> and <code>update</code> actions resemble the <code>new</code> and <code>create</code> actions.
</p>

<p>
  The <code>edit</code> action doesn't need to fetch the article from the database, since this was already handled
  by the <code>initialize</code> method (see <a href="#initialize-finalize">5.1.1 Initialize and finalize</a>).
  The <code>edit</code> action merely needs to render <code>app/views/article/edit.html</code>.
</p>

<p>
  The <code>update</code> action update the article's attribute using the <code>Article::edit</code> method,
  saves the changes to database, then redirects the user to the <code>show</code> action.
</p>

<h4>5.3.1 Finishing up</h4>

<p>
  We can now update an article by visiting its edit page, e.g. <a href="http://localhost:3000/article/1/edit">http://localhost:3000/article/1/edit</a>. To finish up, let's link to the edit page from the bottom of <code>app/views/article/show.html</code>.
</p>

<h3>5.4 Deleting an Article</h3>

<p>
  Finally, we arrive at the "D" (Delete) of CRUD. Deleting a resource is a simpler process than creating or updating.
  It only requires a route and a controller action. And our resourceful routing (<code>resource_actions</code>)
  already provides the route, which maps DELETE /article/:id requests to the destroy action of ArticlesController.
</p>

<p>
  So, let's take a look at the destroy action from <code>app/controllers/article.cpp</code>, below the update action:
</p>

<pre><code class="language-cpp">void ArticleController::destroy()
{
  database.destroy(*model);
  redirect_to("/article");
}
</code></pre>

<p>
  The <code>destroy</code> action calls <code>database.destroy</code> on the model that was fetched in the
  <code>initialize</code> method. Then, it redirects the browser to the article index path.
</p>

<p>
  Now, let's add a link at the bottom of <code>app/views/articles/show.html</code> so that we can delete
  an article from its own page:
</p>

<pre class="filepath">app/views/articles/show.html</pre>
<pre><code class="language-cpp">#include "app/models/article.hpp"
#include &lt;boost/lexical_cast.hpp&gt;

Article&amp; @model;
std::string article_uri = Crails::uri("article", model.get_id());
// END LINKING
&lt;h1&gt;&lt;%= model.get_title() %&gt;&lt;/h1&gt;

&lt;p&gt;&lt;%= model.get_content() %&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;%= link(article_uri + "/edit", "Edit") %&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;%= link(article_uri, "Delete", {
      {"method","delete"}, {"confirm", "Are you sure ?"}
    }) %&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>
  In the above code, we use the <code>Crails::uri()</code> helper to generate an URI from
  parameters: it serializes each parameter as a string and separate them with slashes. In
  this case, it will result in the following string: <code>/article/1</code> (depending on the article id).
</p>

<p>
  Right below, we use the html template <code>link</code> helper to generate our links.
  This helper provides some options allowing us to use the <i>DELETE</i> method in our delete
  link, but also to add a confirm dialog. Note that these options won't work in an environment
  where JavaScript has been disabled.
</p>

<p>
  And that's it! We can now list, show, create, update, and delete articles! InCRUDable!
</p>

<h2>6. Adding a second model</h2>

<p>
  It's time to add a second model to the application. The second model will handle comments on articles.
</p>

<h3>6.1 Generating a Model</h3>

<p>
  We're going to see a similar generator to the one  we used before when creating the <code>Article</code>
  model, views and controllers.
  This time we'll create a <code>Comment</code> model to hold a reference to an article.
  Run this command in your terminal:
</p>

<pre>crails scaffold model -m Comment -p std::string/commenter std::string/body</pre>

<p>
  Now that the model is generated, we'll add a reference to the <code>Article</code> object:
</p>

<pre class="filepath">app/models/comment.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include &lt;crails/odb/model.hpp&gt;
#include &lt;crails/datatree.hpp&gt;
#include "article.hpp" // add the include file for Article

#pragma db object
class Comment : public Crails::Odb::Model
{
  odb_instantiable()
public:
  static const std::string resource_name;

  #pragma db view object(Comment)
  struct Count
  {
    #pragma db column("count(" + Comment::id + ")")
    size_t value;
  };

  void edit(Data);
  void set_body(const std::string&amp; value) { this-&gt;body = value; }
  const std::string&amp; get_body() const { return body; }
  void set_commenter(const std::string&amp; value) { this-&gt;commenter = value; }
  const std::string&amp; get_commenter() const { return commenter; }

  // Add getter and setters for the article property:
  void set_article(const std::shared_ptr&lt;Article&gt;&amp; value) { article = value; }
  const std::shared_ptr&lt;Article&gt;&amp; get_article() const { return article; }

private:
  std::string commenter;
  std::string body;
  std::shared_ptr&lt;Article&gt; article; // Add the article property
};
</code></pre>

<p>
  Now, run the following commands to update your SQL database schema:
</p>

<pre><code>$ crails build
$ build/tasks/odb_migrate/task odb</code></pre>

<p>
  If you check out the SQL table for <code>Comment</code>, you'll see that it now has an <code>article_id</code> column. By default, when loading the model from database, the
  associated <code>Article</code> model will also be loaded within the comment.
</p>

<div class="hint-box">
  Always loading associated objects might not be the best choice for performances. For this reason, you will often rely on <a href="https://www.codesynthesis.com/products/odb/doc/manual.xhtml#10">ODB views</a>
  to customize your queries.
</div>

<h3>6.2 Adding a route for comments</h3>

<p>
  As with the <code>article</code> controller, we will need to add a route so that Crails know where we would like to navigate to see <code>comments</code>. Open up the router file again,
  and edit as below:
</p>

<pre class="filepath">app/routes.cpp</pre>
<pre><code class="language-cpp">#include "app/controllers/comment.hpp" // Add comment controller include
#include "app/controllers/article.hpp"
#include "app/controllers/welcome.hpp"
#include &lt;crails/router.hpp&gt;

void Crails::Router::initialize()
{
  resource_actions(article, ArticleController);
  scope("article/:article_id", [this]()
  {
    resource_actions(comments, CommentController);
  });
  match_action("GET", "/", WelcomeController, index);
}
</code></pre>

<div class="hint-box">
  To learn about routing helpers such as <code>scope</code>, check out the <a href="http://localhost:3000/tutorials/routing/" target="_blank">Routing manual</a>.
</div>

<h3>6.3 Generating a controller</h3>

<p>
  With the model in hand, you can turn your attention to creating a matching controller. This time, we'll use a controller generator:
</p>

<pre>$ crails scaffold controller -m Comment</pre>

<p>
  This creates two files:
</p>

<table>
  <tbody><tr>
    <th>File/Directory</th>
    <th>Purpose</th>
  </tr>
  <tr>
    <td>app/controllers/comment.hpp</td>
    <td>The comment controller header.</td>
  </tr>
  <tr>
    <td>app/controlelrs/comment.cpp</td>
    <td>The comment controller source.</td>
  </tr>
</tbody></table>

<p>
  Like with any blog, our readers will create their comments directly after reading the article, and once they have added their comment,
  will be sent back to the article show page to see their comment now listed. Due to this, our <code>CommentController</code> is there to
  provide a method to create comments and delete spam comments when they arrive.
</p>

<p>
  So first, we'll wire up the Article show template to let us make a new comment:
</p>

<pre class="filepath">app/views/articles/show.html</pre>
<pre><code class="language-html">#include "app/models/article.hpp"
#include "app/models/comment.hpp"

Article&amp; @model;
Comment new_comment;
Crails::FormBuilder&lt;Comment&gt; form =
  Crails::FormBuilder&lt;Comment&gt;(this, new_comment);
std::string new_comment_path =
  Crails::uri("article", model.get_id(), "comments");
// END LINKING
&lt;h1&gt;&lt;%= model.get_title() %&gt;&lt;/h1&gt;

&lt;p&gt;&lt;%= model.get_content() %&gt;&lt;/p&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= form_for(new_comment, new_comment_path) yields %&gt;
  &lt;div&gt;
    &lt;%= form.label_for("commenter") %&gt;
    &lt;%= form.text_field("commenter", &amp;Comment::get_commenter) %&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;%= form.label_for("body") %&gt;
    &lt;%= form.text_area("body", &amp;Comment::get_body) %&gt;
  &lt;/div&gt;
  &lt;input type="submit" value="Send" /&gt;
&lt;% yields-end %&gt;
</code></pre>

<p>
  This adds a form on the <code>Article</code> show page that creates a new comment by calling the <code>CommentController</code> create action.
</p>

<p>
  Let's wire up the <code>create</code> in our comment controller:
</p>

<pre class="filepath">app/controllers/comment.cpp</pre>
<pre><code class="language-cpp">void CommentController::create()
{
  std::shared_ptr&lt;Article&gt; article;
  Comment model;
  auto query = odb::query&lt;Article&gt;::id == params["article_id"];

  if (database.find_one(article, query))
  {
    model.set_article(article);
    model.edit(params[Comment::resource_name]);
    database.save(model);
    redirect_to("article/" + params["article_id"].as&lt;std::string&gt;());
  }
  else
    respond_with(HttpStatus::not_found);
}
</code></pre>

<p>
  You'll see a bit more complexity here than you did in the controller for articles. That's a side-effect of the nesting that you've set up.
  Each request for a comment has to keep track of the article to which the comment is attached, thus the initial call to the
  <code>database.find_one</code>, used with an <code>odb::query</code> to get the article in question.
</p>

<div class="hint-box">
  You can learn more about how to write database queries with <a href="https://www.codesynthesis.com/products/odb/doc/manual.xhtml#4">ODB's manual «Querying the Database » section</a>.
</div>

<p>
  In addition, we call the <code>set_article</code> method we created in the <code>Comment</code> model, before initializing and
  saving the model to database.
</p>

<p>
  Once we have made the new comment, we send the user back to the original article using the <code>redirect_to</code> method.
  As we have already seen, this calls the show action of the <code>ArticleController</code> which in turn renders the <code>show.html</code> template.
  This is where we want the comment to show, so we'll add that to the view in the next chapter.
</p>

<h3>6.4 Display associated comments on an article</h3>

<p>
  We will now add comments on the article show view. Firstly, we need to fetch the comments associated to an article. Open the
  article controller source and edit the <code>show</code> method as following:
</p>

<pre class="filepath">app/controllers/article.cpp</pre>
<pre><code class="language-cpp">#include "app/models/comment.hpp"

...

void ArticleController::show()
{
  odb::result&lt;Comment&gt; comments;
  auto query = odb::query&lt;Comment&gt;::article-&gt;id == model-&gt;get_id();

  database.find&lt;Comment&gt;(comments, query);
  render("article/show", {
    {"comments", &amp;comments}
  });
}
</code></pre>

<p>
  Now, before rendering the show view, our <code>ArticleController</code> will query the database for any comments bound to the fetched article.
  The database fills up a <code>odb::result</code> container which you can then use to loop over each comments.
</p>

<p>
  Lastly, we'll update the view so that it displays each comments above the new comment form:
</p>

<pre class="filepath">app/views/articles/show.html</pre>
<pre><code class="language-html">#include "app/models/article.hpp"
#include "app/models/comment.hpp"

Article&amp; @model;
odb::result&lt;Comment&gt;&amp; @comments; // shared odb::result object
Comment new_comment;
Crails::FormBuilder&lt;Comment&gt; form =
  Crails::FormBuilder&lt;Comment&gt;(this, new_comment);
std::string new_comment_path =
  Crails::uri("article", model.get_id(), "comments");
// END LINKING
&lt;h1&gt;&lt;%= model.get_title() %&gt;&lt;/h1&gt;

&lt;p&gt;&lt;%= model.get_content() %&gt;&lt;/p&gt;

&lt;h2&gt;Comments&lt;/h2&gt;
&lt;% for (const Comment&amp; comment : comments) do %&gt;
  &lt;p&gt;
    &lt;strong&gt;Commenter:&lt;/strong&gt;
    &lt;%= comment.get_commenter() %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;strong&gt;Comment:&lt;/strong&gt;
    &lt;%= comment.get_body() %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= form_for(new_comment, new_comment_path) yields %&gt;
  &lt;div&gt;
    &lt;%= form.label_for("commenter") %&gt;
    &lt;%= form.text_field("commenter", &amp;Comment::get_commenter) %&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;%= form.label_for("body") %&gt;
    &lt;%= form.text_area("body", &amp;Comment::get_body) %&gt;
  &lt;/div&gt;
  &lt;input type="submit" value="Send" /&gt;
&lt;% yields-end %&gt;
</code></pre>

<p>
  Now you can add articles and comments to your blog and have them show up in the right places.
</p>

<h2>7. Security</h2>

<h3>7.1 Basic Authentication</h3>

<p>
  If you were to publish your blog online, anyone would be able to add, edit and delete articles or delete comments.
</p>

<p>
  Crails provides an HTTP authentication system that will work nicely in this situation.
</p>

<p>
  In the <code>ArticlesController</code> we need to have a way to block access to the various actions if the person is
  not authenticated. Here we can use the Crails <code>require_basic_authentication</code> method, which allows access
  to the requested action if that method allows it.
</p>

<p>
  To use the authentication system, we specify it in the <code>initialize</code> method of our <code>ArticleController</code>.
  In our case, we want the user to be authenticated on every action except <code>index</code> and <code>show</code>, so we write
  that:
</p>

<pre class="filepath">app/controllers/article.cpp</pre>
<pre><code class="language-cpp">void ArticleController::initialize()
{
  Crails::Odb::Controller&lt;ApplicationController&gt;::initialize();
  string action_name = get_action_name();

  if (action_name != "index" &amp;&amp; action_name != "show")
    require_basic_authentication("username", "password");

  if (action_name == "show" || action_name == "edit" || action_name == "update" || action_name == "destroy")
    require_model(params["id"]);
}
</code></pre>

<p>
  Now if you try to create a new article, you will be greeted with a basic HTTP Authentication challenge:
</p>

<p>
  TODO: image
</p>

<p>
  After entering the correct username and password, you will remain authenticated until a different username and password
  is required or the browser is closed.
</p>

<p>
  In more advanced use cases, you will want users to be able to register into your application:
  to learn how Crails can help you with this behavior, move on to the <a href="../tutorials/signin">Sign-In</a> tutorial.
</p>

<h3>7.2 Other security considerations</h3>

<p>
  Security, especially in web applications, is a broad and detailed area. Security in your Crails application is covered
  in more depth in the <a href="../tutorials/security">Crails Security Guide</a>.
</p>

<h2>8. What's next ?</h2>

<p>Now that you've seen your first Crails application, you should feel free to update it and experiment on your own.</p>

<p>Remember, you don't have to do everything without help. As you need assistance getting up and running with Rails, feel free to consult these support resources:</p>

<ul>
  <li>The <a href="../tutorials">Crails Guides</a></li>
</ul>

      </div>
    </div>
    <div id="footer">
      This work is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>
      It is a modified version of the <a href="https://guides.rubyonrails.org/">Ruby on Rails guides</a>, amended and completed to fit Crails development.
    </div>
    <script>hljs.initHighlightingOnLoad();</script>
  

</body></html>