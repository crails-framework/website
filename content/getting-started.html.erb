---
title: Getting Started with Crails Framework
---

<div id="with-index"></div>

<h2>1. Guide Assumptions</h2>
<p>
  This guide is designed for beginners who want to get started with Crails from scratch. It does not assume any prior experience with Crails.
</p>

<p>
  We assume you are already familiar with the C++ programming language and CMake building tools.
</p>

<h2>2. Creating a new Crails Application</h2>
<p>
  The best way to read this guide is to follow it step by step. All steps are essential to run this example application and no additional code or steps are needed.
</p>

<p>
  By following this guide, you'll create a very simple weblog.
</p>

<h3>2.1 Installing Crails</h3>
<p>
  First, if you haven't already done it before, you need to install Crails Framework.
  You may do so by following the guide corresponding to your operating system:
</p>
<ul>
  <li><a href="/getting-started/ubuntu.html" target="_blakn">Ubuntu</a></li>
  <li><a href="/getting-started/archlinux.html" target="_blank">ArchLinux</a></li>
</ul>

<h3>2.2 Creating the Blog application</h3>
<p>
  Crails comes with a application generator tool which will provide you the foundation of a fresh Crails application, so that you don't have to write it yourself.
</p>

<p>
  To use this generator, open a terminal, navigate to the directory in which you wish to create the application, and type:
</p>

<pre>$ crails new --name blog</pre>

<p>
  This will create a Crails application called Blog in a `blog` directory.
</p>

<div class="hint-box">
  Take some time to check out the configuration options provided by running <code>crails new -h</code>.
</div>

<p>
  After you create the blog application, switch to its folder:
</p>

<pre>$ cd blog</pre>

<p>
  The <code>blog</code> directory has a number of auto-generated files and folders that make up the structure of a Crails application. Most of the work in this tutorial will happen in the <code>app</code> folder, but here's a basic rundown on the function of each file and folders that Crails created by default:
</p>

<table>
  <tr>
    <th>File/Folder</th>
    <th>Purpose</th>
  </tr>
  <tr>
    <td>app/</td>
    <td>Contains the controllers, models, views, helpers, mailers and assets for your application.</td>
  </tr>
  <tr>
    <td>app/main.cpp</td>
    <td>This file contains the entry point for the server binary.</td>
  </tr>
  <tr>
    <td>app/routes.cpp</td>
    <td>This is where you'll bind your routes with your controller methods.</td>
  </tr>
  <tr>
    <td>build/</td>
    <td>Output for your application binaires: server, tasks, anything from your application that can be executed will end up in this folder.</td>
  </tr>
  <tr>
    <td>config/</td>
    <td>Configure your application's database, <a href="/request_pipeline">request pipeline</a> and several optional features of Crails.</td>
  </tr>
  <tr>
    <td>lib/</td>
    <td>This folder is used for application code that you haven't written yourself. Crails uses several code generating utilities: the <code>lib</code> folder is where this code will be generated and compiled from</td>
  </tr>
  <tr>
    <td>logs/</td>
    <td>In a production environment, this is where your application's log files will be stored</td>
  </tr>
  <tr>
    <td>public/</td>
    <td>The only folder seen by the world as-is. Contains static files and compiled assets.</td>
  </tr>
  <tr>
    <td>spec/</td>
    <td>This is where you'll write tests for your application.</td>
  </tr>
  <tr>
    <td>CMakeLists.txt</td>
    <td>Contains a set of directives describing the project's source files, dependencies, and build targets.</td>
  </tr>
  <tr>
    <td>.crails</td>
    <td>This file is managed by the command line interface tool, and records several settings about your project used when building or generating code.</td>
  </tr>
</table>

<h2>3. Hello, Crails!</h2>
<p>
  To begin with, let's get some text up on screen quickly. Let's get your Crails application running:
</p>

<h3>3.1 Starting up the web server</h3>
<pre><code>$ crails build
$ build/server</code></pre>

<p>
  The first command will compile your application. The second one
  will fire up your server binary. To see your application in action, open a browser window and navigate to <a href="http://localhost:3000" target="_blank">http://localhost:3000</a>. You should see the Crails default information page:
</p>

<img src="/images/crails-welcome-page-screenshot.png" />

<div class="hint-box">
  To stop the web server, hit Ctrl+C in the terminal window where it's running. To verify the server has stopped you should see your command prompt cursor again. Note that changes you make to your application's code won't get picked up by the server unless you run a new compilation using <code>crails build</code> and then restart the server.
</div>

<p>
  The Crails default information page is the smoke test for a new Crails application: it makes sure that your application is configured correctly and can receive and respond to http queries.
</p>

<h3>3.2 Say "Hello", Crails</h3>

<p>
  To get Crails to say "Hello", you need to create at minimum a <i>route</i>, a <i>controller</i> and a <i>view</i>. A route maps a request to a controller action. A controller action performs the necessary work to handle the request, and prepares any data for the view. A view displays data in the desired format.
</p>

<p>
  To create a new controller, we'll run the controller generator:
</p>

<pre>$ crails scaffold controller -n Welcome</pre>

<p>
  This will generate two files: <code>app/controllers/welcome.hpp</code> and <code>app/controllers/welcome.cpp</code>. Let's take a look at those:
</p>

<%= code_block <<CPP
// app/controllers/welcome.hpp
#pragma once
#include "app/controllers/application.hpp"

class WelcomeController : public ApplicationController
{
public:
  WelcomeController(Crails::Context& context);

  void initialize() override;
  void finalize() override;
};

#endif
CPP
%>

<%= code_block <<CPP
// app/controllers/welcome.cpp
#include "welcome.hpp"

using namespace std;

WelcomeController::WelcomeController(Crails::Context& context)
  : ApplicationController(context)
{
}

void WelcomeController::initialize()
{
  ApplicationController::initialize();
}

void WelcomeController::finalize()
{
  ApplicationController::finalize();
}
CPP
%>

<p>
  This is a basic skeleton for a controller. We will now add an <code>action</code> to the controller by adding the <code>index</code> method:
</p>

<%= code_block <<CPP
// app/controllers/welcome.hpp
#pragma once
#include "app/controllers/application.hpp"

class WelcomeController : public ApplicationController
{
public:
  WelcomeController(Crails::Context& context);

  void initialize() override;
  void finalize() override;

  void index()
  {
    render(TEXT, "Hello world!"); // will respond to the action
                                  // with a plain text answer
  }
};

#endif
CPP
%>

<p>
  Then, you need to register a new route in <code>app/routes.cpp</code>:
</p>

<%= code_block <<HTML
#include <crails/router.hpp>;
#include "controller/welcome.hpp"

void Crails::Router::initialize()
{
  match_action("GET", "/", WelcomeController, index);
}
HTML
%>

<div class="hint-box">
  For more information about routing, refer to the <a href="/tutorials/routing">Crails Routing guide</a>
</div>

<p>
  Lastly, remove the default <code>index.html</code> file (otherwise, it will be served by default as the root of your application)
</p>

<pre><code>$ rm public/index.tml</code></pre>

<p>
  We're good to go. Compile your code and restart the server to get it to pick up your changes:
</p>

<pre><code>$ crails build
$ build/server</code></pre>

<p>
  Then, open <a href="http://localhost:3000" target="_blank">http://localhost:3000</a> in a web browser. You'll see a simple text response saying "Hello world!".
</p>

<h3>3.3 Say "Hello" with HTML</h3>

<p>
  In the last section, our server gave a response using the <code>text/plain</code> format. To provide an HTML response, you'll need to create a view.
</p>

<p>
  A view's purpose is to display this information in a human readable format. An important distinction to make is that it is the <i>controller</i>, not the view, where information is collected. The view should just display that information. By default, view templates are written in a language called ecpp (Embedded C++) which is used to generate the C++ code for your views.
</p>

<p>
  First, you need to enable html views in your application. To do that, you need to add the <code>html</code> renderer to your application, by running the following command:
</p>

<pre><code>$ crails formats --add html</code></pre>

<p>
  Now, we'll add a new folder at <code>app/views/welcome</code> to create an ecpp template named <code>app/views/welcome/index.html</code>
</p>

<%= html_block <<HTML
<html>
  <head>
    <title>Hello world!</title>
  </head>
  <body>
    This view has been generated from an ecpp template.
  </body>
</html>
HTML
%>

<p style="text-align: left">
  We also need to update our controller at <code>app/controllers/welcome.hpp</code>so that it responds using our view:
</p>

<%= code_block <<CPP
#pragma once
#include "app/controllers/application.hpp"

class WelcomeController : public ApplicationController
{
public:
  WelcomeController(Crails::Context& context);

  void initialize() override;
  void finalize() override;

  void index()
  {
    render("welcome/index"); // <-- renders the html view
  }
};
CPP
%>

<p>
  Compile and restart your server, then go to <a href="http://localhost:3000" target="_blank">http://localhost:3000</a> to see that your application now provides an HTML response.
</p>

<h2>4. Getting Up and Running</h2>

<p>
  Now that you've seen how to create a controller, an action, and a view, let's create something with a bit more substance.
</p>

<p>
  In the Blog application, you will now create a new resource. A resource is the term used for a collection of similar objects, such as articles, people, or animals. You can create, read, update, and destroy items for a resource and these operations are referred to as CRUD operations.
</p>

<h3>4.1 Setting up a database</h3>

<p>
  Resources need to be persistent, and for that, we will be using an SQL database. The preferred method for that is to use the <a href="https://www.codesynthesis.com/products/odb/" target="_blank">ODB ORM</a>. We provide a plugin to integrate it with our controller and building system. Let's install it:
</p>

<pre>$ crails plugins odb install -b sqlite</pre>

<p>
  This will update your CMakeLists.txt to link your application to the odb libraries, generate a default configuration for an <i>sqlite</i> database, and adds the odb_migrate task which we'll describe later on.
</p>

<div class="hint-box">
  Check out the <a href="#">Crails Databases manual</a> to learn more about the configuration options for databases with crails.
</div>

<h3>4.2 Creating an MVC resource</h3>

<p>
  Now that our database is configured, we will create a set of model, views and controllers. To generate it
  all at once, we will use the resource generator:
</p>

<pre>$ crails scaffold resource -m Article -p std::string/title std::string/content</pre>

<p>
This will create the following files:
</p>

<table>
  <tr>
    <th>File</th>
    <th>Purpose</th>
  </tr>
  <tr>
    <td>app/models/article.hpp</td>
    <td>odb-based model</td>
  </tr>
  <tr>
    <td>app/models/article.cpp</td>
    <td>model implementation</td>
  </tr>
  <tr>
    <td>app/controllers/article.hpp</td>
    <td>odb-based controller with CRUD actions</td>
  </tr>
  <tr>
    <td>app/controllers/article.cpp</td>
    <td>controller implementation</td>
  </tr>
  <tr>
    <td>app/views/article/index.html</td>
    <td>lists an index of article loaded by the controller</td>
  </tr>
  <tr>
    <td>app/views/article/show.html</td>
    <td>shows a single article loaded by the controller</td>
  </tr>
  <tr>
    <td>app/views/article/new.html</td>
    <td>displays a form to create a new article</td>
  </tr>
  <tr>
    <td>app/views/article/edit.html</td>
    <td>displays a form to edit an existing article</td>
  </tr>
  <tr>
    <td>app/views/article/form.html</td>
    <td><a href="/tutorials/layouts#partial-rendering">partial view</a> containing the form used in the <i>new</i> and <i>edit</i> views.</td>
  </tr>
</table>

<p>
  The <code>app/routes.cpp</code> file will also be modified to connect our controller's actions:
</p>

<%= code_block <<CPP
// app/routes.hpp
#include "app/controllers/article.hpp"
#include "app/controllers/welcome.hpp"
#include <crails/router.hpp>

void Crails::Router::initialize()
{
  resource_actions("article", ArticleController);
  match_action("GET", "/", WelcomeController, index);
}
CPP
%>

<p>
  The <code>resource_actions</code> macro creates routes for all the actions in our resource controller. You can learn more about the <code>resource_actions</code> macro in the <a href="/tutorials/routing#resource_actions">Routing guide</a>.
</p>

<h3>4.3 Database Migrations</h3>

<p>
  <i>Migrations</i> are used to alter the structure of an application's database. In Crails applications,
  migrations are written in XML and C++ so they can be database agnostic.
</p>

<div class="hint-box">
  In the simplest scenarios, the <i>odb</i> compiler generates an <i>application.xml</i> file that tracks
  changes to the database schema. In most cases, this is enough to handle updates to your databases, though
  you can also run C++ code between migrations (for instance, when you need to change the content of a
  column during a migration). Check that out in the <a href="/tutorials/odb_migrations">Migrations with ODB</a> manual.
</div>

<p>
  To create or update a database table schema, we will have to use the <i>odb_migrate</i> task:
</p>

<pre>$ crails build # don't forget to build your project first
$ build/tasks/odb_migrate/task -c odb</pre>

<p>
  The <i>-c</i> option tells the migrating task to create the database if it does not already exist.
</p>

<p>
  The <i>odb</i> parameter points to a specific database configured in our project, which you can find in
  the <code>config/databases.cpp</code> file which was generated when we installed the odb plugin.
</p>

<h3>4.4 Showing a list of Articles</h3>

<p>
  Let's take a look at the controller we just generated, at <code>app/controllers/article.cpp</code>.
  The generator defined two methods used to show an index of article: the <code>find_list</code> and
  <code>index</code> methods:
</p>

<%= code_block <<CPP
void ArticleController::find_list()
{
  odb::result<Article> results;

  database.find(results);
  model_list = Crails::Odb::to_vector<Article>(results);
  vars["models"] = &model_list;
}

void ArticleController::index()
{
  find_list();
  render("article/index");
}
CPP
%>

<p>
  The <code>find_list</code> method fetches all the Article objects stored in database, and store the
  results in <code>model_list</code>, which is a container declared in our generated controller.
</p>

<p>
  Notice the <code>vars["models"] = &amp;model_list</code> assignation. The <code>vars</code> object
  is used to share variables with views. We'll now take a look at the <i>index</i> view and see how
  to read the contents of this variable.
</p>

<p>
  Open the <code>app/views/article/index.html</code> file, and replace its contents as following:
</p>

<%= html_block <<HTML
#include "app/models/article.hpp"

std::vector<Article>& @models;
// END LINKING
<h1>Article index</h1>

<ul>
  <% for (const Article& article : models) do %%>
    <li>
      <%= article.get_name() %%>
    </li>
  <% end %%>
</ul>
HTML
%>

<p>
  The above code is a mixture of HTML and <i>ECPP</i>. ECPP is a templating system that generates C++
  from markup documents. Here, we can see two types of ECPP tags: <code>&lt;% %&gt;</code> and
  <code>&lt;%= %&gt;</code>. The <code>&lt;% %&gt;</code> tag means "evaluate the enclosed C++ code".
  The <code>&lt;%= %&gt;</code> means "evaluate the enclosed C++ code, and output the value it returns".
  Anything you could write in the body of a C++ function can go inside these ECPP tags, though it's
  usually best to keep the contents of ERB tags short, for readability.
</p>

<div class="hint-box">
  ECPP is based on <code>std::stringstream</code>, which means the <code>&lt;%= %&gt;</code> tags can
  output anything supported by a <code>std::stringstream</code>.
</div>

<p>
  We can see the final result by visiting <a href="http://localhost:3000/article">http://localhost:3000/article</a>.
  (Remember that <code>build/server</code> server must be running!) Here's what happens when we do that:
</p>

<p>
  1. The browser makes a request <code>GET http://localhost:3000/article</code><br/>
  2. Our Crails application receive the request<br/>
  3. The Crails router maps the article route to the <i>index</i> action of <code>ArticleController</code><br/>
  4. The <i>find_list</i> method uses the <code>Article</code> model and the <code>database</code> object to fetch all articles from the database.<br/>
  5. The <i>index</i> action renders the <i>app/views/article/index.html</i> view.<br/>
  6. The ECPP template is evaluated and outputs HTML.<br/>
  7. The server sends a repsonse containing the HTML back to the browser.
</p>

<p>
  We've connected all the MVC pieces together, and we have our first controller action! Next, we'll move on to the second action.
</p>

<h2>5. CRUDit where CRUDit is due</h2>

<p>
  Almost all web applications involve <a href="https://en.wikipedia.org/wiki/Create,_read,_update,_and_delete">CRUD (Create, Read, Update, and Delete)</a> operations. You may even find that the majority of the work your application does is CRUD. Crails acknowledges this, and provides many features to help simplify code doing CRUD.
</p>

<p>
  Let's begin exploring these features by adding more functionality to our application.
</p>

<h3>5.1 Showing a Single Article</h3>

<p>
  We currently have a view that lists all articles in our database. Let's add a new view that shows the title and body of a single article.
</p>

<p>
  The resource generator we used earlier already generated the route and controller methods needed. Let's take
  a look at the controller's code at <code>app/controllers/article.cpp</code>:
</p>

<%= code_block <<CPP
std::shared_ptr<Article> ArticleController::find_model(Crails::Odb::id_type id)
{
  database.find_one(model, odb::query<Article>::id == id);
  vars["model"] = model.get();
  return model;
}

void ArticleController::require_model(Crails::Odb::id_type id)
{
  if (!model && !find_model(id))
    respond_with(Crails::HttpStatus::not_found);
}

void ArticleController::show()
{
  render("article/show");
}
CPP
%>

<p>
  Three methods are involved in showing a single article:
  <ul>
    <li>
      <i>find_model</i> should look familiar. Instead of fetching a list of articles, it fetches a single
      article, looking up for its ID. It then stores a pointer to the article object in the <code>vars</code> object.
    </li>
    <li>
      <i>require_model</i> calls <i>find_model</i>, and uses <i>respond_with</i> to respond with <i>404 not found</i>
      when no model were found.
    </li>
    <li>
      <i>show</i> renders the <i>app/views/article/show.html</i> view.
    </li>
  </ul>
</p>

<p>
  You might've noticed that the <i>require_model</i> method isn't being called by the <i>show</i> action. In
  simple cases, you may want to fetch the model directly from the action. But since multiple actions will need
  to fetch a model, we'll use the <i>initialize</i> method instead.
</p>

<h4 id="initialize-finalize">5.1.1 Initialize and finalize</h4>

<p>
  Before and after running each action on a controller, the <code>initialize</code> and <code>finalize</code> methods
  will be called. This can be useful when several actions need to be setup in similar ways.
</p>

<p>
  Let's take a look at the <code>initialize</code> method generated for our <code>ArticleController</code>:
</p>

<%= code_block <<CPP
void ArticleController::initialize()
{
  Crails::Odb::Controller<ApplicationController>::initialize();
  string action_name = get_action_name();

  if (action_name == "show" || action_name == "edit" || action_name == "update" || action_name == "destroy")
    require_model(params["id"]);
}
CPP
%>

<p>
  In this initializer, we use <code>get_action_name</code> to figure out which action is about to be triggered.
  If said action requires a single article model to be loaded, we call <code>require_model</code>.
</p>

<div class="hint-box">
  When a request's response is provided within an initializer, the <i>action</i> method won't be called at all.
  The <i>finalize</i> method, however, is always called.
</div>

<p>
  As we've seen earlier, the <code>require_model</code> method already provides a response by calling
  <code>respond_with</code> when the resource was not found. In such cases, the <code>show</code> method will
  only be called when an Article object is loaded within the shared variable object (<code>vars</code>).
</p>

<h4>5.1.2 Setting up the show view</h4>

<p>
  Let's create our show view by replacing the content of <code>app/views/article/show.html</code> with the
  following contents:
</p>

<%= html_block <<HTML
#include "app/models/article.hpp"
Article& @model;
// END LINKING
<h1><%= model.get_title() %%></h1>

<p><%= model.get_content() %%></p>
HTML
%>

<p>
  Now we can see the article when we visit <a href="http://localhost:3000/article/1">http://localhost:3000/article/1</a>!
</p>

<p>
  To finish up, let's add a convenient way to get to an article's page. We'll link each article's title in <code>app/views/article/index.html</code> to its page:
</p>

<%= html_block <<HTML
#include "app/models/article.hpp"

std::vector<Article>& @models;
// END LINKING
<h1>Article index</h1>

<ul>
  <% for (const Article& article : models) do %%>
    <li>
      <a href="/article/<%= article.get_id() %%>">
        <%= article.get_name() %%>
      </a>
    </li>
  <% end %%>
</ul>
HTML
%>

<h3>5.2 Creating a New Article</h3>

<p>
  Now we move on to the "C" (Create) of CRUD. Typically, in web applications, creating a new resource is a multi-step process. First, the user requests a form to fill out. Then, the user submits the form. If there are no errors, then the resource is created and some kind of confirmation is displayed. Else, the form is redisplayed with error messages, and the process is repeated.
</p>

<p>
  In a Rails application, these steps are conventionally handled by a controller's <code>new_</code> and <code>create</code> actions. Let's check out the implementation of these actions in our generated controller at <code>app/controllers/articles.cpp</code>:
</p>

<%= code_block <<CPP
void ArticleController::new_()
{
  render("article/new");
}

void ArticleController::create()
{
  Article model;
  model.edit(params[Article::resource_name]);
  database.save(model);
  redirect_to("/article/" + boost::lexical_cast<std::string>(model.get_id()));
}
CPP
%>

<p>
  The <code>new</code> action is very simple, and merely renders the <code>app/views/article/new.html</code> view.
</p>

<p>
  The <code>create</code> action instantiates a new article, and initialize its properties from parameters using
  <code>model.edit(params[Article::resource_name])</code>. It then persists the model to database by calling <code>database.save(model)</code>. At this point, the model should have an ID assigned to it: we use this ID to respond with a 303
  redirection, by calling <code>redirect_to</code> towards the <i>show</i> route for the article model.
</p>

<h4>5.2.1 New view</h4>

<p>
  Let's take a look at the <code>app/views/article/new.html</code> view that was generated with the <code>crails scaffold resource</code> command:
</p>

<%= html_block <<HTML
#include "app/models/article.hpp"
Article model;
// END LINKING
<h1>New Article</h1>
<%= partial("article/form", {{"model", &model}} %%>
HTML
%>

<p>
  The <code>new.html</code> view is very simple: it instantiate an empty Article, then renders a <i>partial view</i>
  that contains the form for our article model. Using a partial for the form allows us to use the same HTML for
  both the creation and updating forms. Let's head over to the form partial to see what's going on there.
</p>

<div class="hint-box">You can read more about partials in the <a href="/tutorials/layouts#partial-rendering">crails-html layout and rendering</a> guide.</div>

<h4>5.2.2 Using a form builder</h4>

<p>
  We will use a feature of Rails called a form builder to create our form. Using a form builder, we can write a minimal amount of code to output a form that is fully configured and follows Crails conventions.
</p>

<p>
  Let's replace the contents of <code>app/views/article/form.html</code> with the following:
</p>

<%= html_block <<HTML
#include "app/models/article.hpp"
#include <crails/html_form_builder.hpp>

Article& @model;
Crails::FormBuilder<Article> form = Crails::FormBuilder<Article>(this, model);
// END LINKING
<%= form_for(model, "/article") yields %%>
  <div>
    <%= form.label_for("title") %%>
    <%= form.text_field("title", &Article::get_title) %%>
  </div>
  <div>
    <%= form.label_for("content") %%>
    <%= form.text_area("content", &Article::get_content) %%>
  </div>
<% yields-end %%>
HTML
%>

<p>
  The <code>form_for</code> creates a &lt;form&gt; tag with the proper action and method attributes.
  It also includes the CSRF token for the query (<a href="/about-csrf">About CSRF</a>).
</p>

<p>
  Then, we use the <code>Crails::FormBuilder</code> template class and call methods like <code>label_for</code>
  and <code>text_field</code> to output the appropriate form elements.
</p>

<p>
  The resulting output from out <code>form_for</code> call will look like:
</p>

<%= html_block <<HTML
<form action="/article" method="post">
  <input type="csrf-token" value="...">
  <div>
    <label for="article[title]">title</label>
    <input type="text" name="article[title]">
  </div>
  <div>
    <label for="article[content]">content</label>
    <textarea name="article[content]"></textarea>
  </div>
</form>
HTML
%>

<div class="hint-box">
  To learn more about form builders, see <a href="/tutorials/form-builder">Html form helpers</a>.
</div>

<h4>5.2.3 Finishing up</h4>

<p>
  We can now create an article by visiting <a href="http://localhost:3000/article/new">http://localhost:3000/article/new</a>. To finish up, let's link to that page from the bottom of <code>app/views/article/index.html</code>:
</p>

<%= html_block <<HTML
#include "app/models/article.hpp"

std::vector<Article>& @models;
// END LINKING
<h1>Article index</h1>

<ul>
  <% for (const Article& article : models) do %%>
    <li>
      <%= article.get_name() %%>
    </li>
  <% end %%>
</ul>

<a href="/article/new">New Article</a>
HTML
%>

<h3>5.3 Updating an Article</h3>

<p>
  We've covered the "CR" of CRUD. Now let's move on to the "U" (Update). Updating a resource is very similar to creating a resource. They are both multi-step processes. First, the user requests a form to edit the data. Then, the user submits the form. If there are no errors, then the resource is updated. Else, the form is redisplayed with error messages, and the process is repeated.
</p>

<p>
  These steps are conventionally handled by a controller's <code>edit</code> and <code>update</code> actions. Let's take a look at the implementation of these actions that was generated by our <i>scaffold</i> at <code>app/controllers/article.hpp</code>, below the create action:
</p>

<%= code_block <<CPP
void ArticleController::edit()
{
  render("article/edit");
}

void ArticleController::update()
{
  model->edit(params[Article::resource_name]);
  database.save(*model);
  redirect_to("article/" + boost::lexical_cast<std::string>(model->get_id()));
}
CPP
%>

<p>
  Notice how the <code>edit</code> and <code>update</code> actions resemble the <code>new</code> and <code>create</code> actions.
</p>

<p>
  The <code>edit</code> action doesn't need to fetch the article from the database, since this was already handled
  by the <code>initialize</code> method (see <a href="#initialize-finalize">5.1.1 Initialize and finalize</a>).
  The <code>edit</code> action merely needs to render <code>app/views/article/edit.html</code>.
</p>

<p>
  The <code>update</code> action update the article's attribute using the <code>Article::edit</code> method,
  saves the changes to database, then redirects the user to the <code>show</code> action.
</p>

<h4>5.3.1 Finishing up</h4>

<p>
  We can now update an article by visiting its edit page, e.g. <a href="http://localhost:3000/article/1/edit">http://localhost:3000/article/1/edit</a>. To finish up, let's link to the edit page from the bottom of <code>app/views/article/show.html</code>.
</p>

<h3>5.4 Deleting an Article</h3>

<p>
  Finally, we arrive at the "D" (Delete) of CRUD. Deleting a resource is a simpler process than creating or updating.
  It only requires a route and a controller action. And our resourceful routing (<code>resource_actions</code>)
  already provides the route, which maps DELETE /article/:id requests to the destroy action of ArticlesController.
</p>

<p>
  So, let's take a look at the destroy action from <code>app/controllers/article.cpp</code>, below the update action:
</p>

<%= code_block <<CPP
void ArticleController::destroy()
{
  database.destroy(*model);
  redirect_to("/article");
}
CPP
%>

<p>
  The <code>destroy</code> action calls <code>database.destroy</code> on the model that was fetched in the
  <code>initialize</code> method. Then, it redirects the browser to the article index path.
</p>

<p>
  Now, let's add a link at the bottom of <code>app/views/articles/show.html</code> so that we can delete
  an article from its own page:
</p>

<%= code_block <<CPP
#include "app/models/article.hpp"
Article& @model;
// END LINKING
<h1><%= model.get_title() %%></h1>

<p><%= model.get_content() %%></p>

<ul>
  <li>
    <a href="/article/<%= model.get_id() %%>/edit">
      <button>Edit</button>
    </a>
  </li>
  <li>
    <%= form_for(model, "/article", {{"method","delete"}}) yields %%>
      <input type="submit" value="Delete">
    <% yields-end %%>
  </li>
</ul>
CPP
%>

<p>
  In the above code, we use a &lt;form&gt; to create a destroy link, since the http verb we need to use to
  reach our destroy action is <i>DELETE</i>, rather than <i>GET</i>.
</p>

<p>
  And that's it! We can now list, show, create, update, and delete articles! InCRUDable!
</p>

<h2>6. Adding a second model</h2>

<p>
  It's time to add a second model to the application. The second model will handle comments on articles.
</p>

<h3>6.1 Generating a Model</h3>

<p>
  We're going to see a similar generator to the one  we used before when creating the <code>Article</code>
  model, views and controllers.
  This time we'll create a <code>Comment</code> model to hold a reference to an article.
  Run this command in your terminal:
</p>

<pre>crails scaffold model -m Comment -p std::string/commenter std::string/body</pre>

<p>
  This command only generates the Model files.
</p>

<!--
<div class="hint-box">
  You can learn more about how to write database queries with <a href="https://www.codesynthesis.com/products/odb/doc/manual.xhtml#4">ODB's manal «Querying the Database » section</a>.
</div>
-->

<h2>10. What's next ?</h2>

<p>Now that you've seen your first Crails application, you should feel free to update it and experiment on your own.</p>

<p>Remember, you don't have to do everything without help. As you need assistance getting up and running with Rails, feel free to consult these support resources:</p>

<ul>
  <li>The <a href="/tutorials">Crails Guides</a></li>
</ul>
