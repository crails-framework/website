<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <title>Crails Framework - Crails Framework: WebSockets with Crails and Comet</title>
    <link rel="stylesheet" href="../../css/application.css">
    <link rel="stylesheet" href="../../css/code-qtcreator.css">
    <script src="../../highlight.pack.js"></script>
    <script src="../../js/index.js"></script>

    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="Nanoc 4.12.7">
  </head>
  <body>
    <div id="header">
      <img class="logo" src="../../images/logo.png">
      <h1>Crails Framework</h1>
      <ul class="main-menu">
        <li><a href="../../">Home</a></li><li>
            <a href="../../getting-started">Getting started</a></li><li>
            <a href="..">Tutorials</a></li><li>
	    <a href="https://github.com/crails-framework/crails" target="_blank">GitHub</a></li>
      </ul>
    </div>
    <div id="content-wrapper">
      <div id="main">
        <div id="with-index"></div>

<h2>1. Introduction</h2>
<p>
  In the following tutorial, we will learn how to use websockets by creating a simple chat-room application.
  The tutorial will be divided in three parts:<br>
  - the first part will focus on setting up a Crails+Comet application for the tutorial.<br>
  - the second part will be targeted at server-side web sockets with Crails.<br>
  - the third part will be targeted at client-side web sockets with Comet.<br>
  Before we dwelve into websockets, let's create our development environment using the crails comment line interface:
</p>

<h3>1.1 Creating a Crails+Comet application</h3>
<p>
  First things first, let's create a simple crails application:
</p>

<pre>$ crails new -n chatroom -p html
</pre>

<p>
  This will create a basic application with html support. Next, we need to add a comet client, which
  we will create using the comet plugin:
</p>

<pre>$ crails plugins comet install
</pre>

<h3>1.2 Creating a controller and layout</h3>
<p>
  Even though we'll be making a Single-Page-Application using Comet, we still need to provide a route to
  serve a basic html file which will provide a layout including the required stylesheets and javascript files.
  Let's start with creating the controller:
</p>

<pre>$ crails scaffold controller -n home
</pre>

<p>
  Now, we will create a simple default layout:
</p>

<pre>$ crails scaffold layout
</pre>

<p>
  The default options for the layout generator will create the <code>layouts/application</code> layout.
  The next step is to add an action to our <i>home</i> controller that will render our layout. First,
  update the header to add the<code>homepage</code> action:
</p>

<pre class="filepath">app/controllers/home.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include "app/controllers/application.hpp"

class HomeController : public ApplicationController
{
public:
  HomeController(Crails::Context&amp;);

  void initialize() override;
  void finalize() override;

  // Add our new action here:
  void homepage();
protected:
};
</code></pre>

<p>
  Then, let's implement the <code>homepage</code> action in the controller's source file:
</p>

<pre class="filepath">app/controllers/home.cpp</pre>
<pre><code class="language-cpp">#include "home.hpp"
#include &lt;crails/params.hpp&gt;

...

void HomeController::homepage()
{
  render("layouts/application");
}
</code></pre>

<p>
  This might seem unorthodox... and it is. Usually, you would render a view within a layout. In this context,
  we are directly rendering the layout as if it were a simple view. This is absolutely possible, and it fits
  our current needs better, as rendering the views will be handled by the client rather than the server.
</p>

<p>
  To finish up our homepage route, we need to reference it in the router:
</p>

<pre class="filepath">app/routes.cpp</pre>
<pre><code class="language-cpp">#include &lt;crails/router.hpp&gt;
#include "app/controllers/home.hpp" // adds the include for our HomeController

void Crails::Router::initialize(void)
{
  match_action("GET", "/", HomeController, homepage); // references the homepage action as the root action ("/")
}
</code></pre>

<h3>1.3 Serving the Comet application from the layout</h3>

<p>
  Last step, we need to serve the JavaScript for our comet application. This is done using the <code>lib/assets.hpp</code>
  header, a generated file which provides the definitive URIs towards your application assets.
</p>

<p>
  In order to take a peek at what this header will look like, let's try building your application:
</p>

<pre>$ crails build</pre>

<p>
  Everything should go smoothly, and the <lib>lib/assets.hpp file should've been generated. Let's check it out:
</lib></p>

<pre class="filepath">lib/assets.hpp</pre>
<pre><code class="language-cpp">#ifndef APPLICATION_ASSETS_HPP
#define APPLICATION_ASSETS_HPP
namespace Assets
{
#ifndef __CHEERP_CLIENT__
  extern const char* application_js;
#endif
  extern const char* stylesheets_bootstrap_bootstrap_scss;
}
#endif
</code></pre>

<p>
  See the <code>application_js</code> variable ? That's what we're interested about. This variable will contain the path
  for our asset from the web. This is what we need to add to our layout to serve our comet application. Let's go and add
  a &lt;script&gt; in our layout's header:
</p>

<pre class="filepath">app/views/layouts/application.html</pre>
<pre><code class="language-cpp">#include "lib/assets.hpp"

const char* @yield = nullptr;
// END LINKING
&lt;html&gt;
  &lt;head&gt;
    &lt;%= tag("link", {{"rel","stylesheet"},{"href",Assets::stylesheets_bootstrap_bootstrap_scss}}) %&gt;

    &lt;!-- Add the following script tag: --&gt;
    &lt;%= tag("script", {{"src",Assets::application_js}}) yields %&gt;&lt;% yields-end %&gt;

  &lt;/head&gt;
  &lt;body&gt;
    &lt;% if (yield != nullptr) do %&gt;
      &lt;%= yield %&gt;
    &lt;% end %&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>
  And that's all there is to it ! Our setup is ready : we can now go on and dwelve into WebSockets !
</p>

<h2>2. WebSocket server with Crails</h2>
<h3>2.1 A simple echo websocket</h3>

<p>
  To familiarize with the WebSocket API, let's start by writing a simple <i>echo</i> websocket. It's a
  websocket that will merely send back everything that it receives.
</p>

<p>
  Let's start by scaffolding our websocket class:
</p>

<pre class="filepath">app/controllers/echo_web_socket.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include &lt;crails/websocket.hpp&gt;

class EchoWebSocket : public Crails::WebSocket
{
public:
  EchoWebSocket(Crails::Context&amp; context) : Crails::WebSocket(context)
  {
  }
};
</code></pre>

<p>
  All we need to create a valid websocket is to inherit <code>Crails::WebSocket</code> and create a constructor that
  passes a <i>context</i> object to the superclass.
</p>

<p>
  This websocket, however, does nothing yet. We will now override the <i>received</i> method to send back any received
  messages:
</p>

<pre class="filepath">app/controllers/echo_web_socket.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include &lt;crails/websocket.hpp&gt;

class EchoWebSocket : public Crails::WebSocket
{
public:
  EchoWebSocket(Crails::Context&amp; context) : Crails::WebSocket(context)
  {
  }

  void received(const std::string&amp; message, Crails::WebSocket::MessageType type) override
  {
    send(message, type);
  }
};
</code></pre>

<p>
  Simple stuff ! And we're almost done: we now need to register our WebSocket object in the router, so that it can
  wire requests towards it. Edit the routes as following:
</p>

<pre class="filepath">app/routes.cpp</pre>
<pre><code class="language-cpp">#include &lt;crails/router.hpp&gt;
#include "app/controllers/home.hpp"
#include "app/controllers/echo_web_socket.hpp" // adds the include for our EchoWebSocket

void Crails::Router::initialize(void)
{
  match_action("GET", "/", HomeController, homepage);
  match_websocket("/echo", EchoWebSocket, read); // references our websocket at "/echo"
}
</code></pre>

<p>
  Matching websockets routes is very similar to controller routes. Like for controllers, you also need to specify
  an <i>action</i> as the third parameter of a route: the action specified will trigger right after the WebSocket
  handshake is completed. In this case, we've used <code>read</code> as our action.
</p>

<p>
  The <code>read</code> action is provided by <code>Comet::WebSocket</code>: you don't have to implement it yourself.
  It is basically what you would expect from reading on a socket: it asynchronously waits for the client to send
  data, and calls <code>received</code> (which we've implemented earlier) once a message has been received.
</p>

<h3>2.2 Chatroom server</h3>

<p>
  Let's capitalize on our newly aquired knowledge by writing a simple chatroom server. Our goal will be to
  echo each message received from one websocket to all other websockets connected to the chatroom.
</p>

<p>
  To that end, we will need to make a chatroom storing all the connected websockets. It will need to be a <i>thread-safe</i>
  chatroom, as distincts clients could connect, disconnect and emit messages simultaneously.
</p>

<p>
  Let's have a go at it:
</p>

<pre class="filepath">app/controllers/chat_room.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include &lt;crails/websocket.hpp&gt;
#include &lt;crails/utils/singleton.hpp&gt;
#include &lt;mutex&gt;

class ChatRoom
{
  SINGLETON(ChatRoom) // singleton helper from the framework
  typedef std::shared_ptr&lt;Crails::WebSocket&gt; WebSocketPtr;
  typedef std::list&lt;WebSocketPtr&gt;            Clients;
public:
  void add_client(Crails::WebSocket&amp; socket)
  {
    std::lock_guard&lt;std::mutex&gt; guard(clients_mutex);

    clients.push_back(socket.shared_from_this());
  }

  void remove_client(const Crails::WebSocket&amp; socket)
  {
    Clients::iterator it;

    std::lock_guard&lt;std::mutex&gt; guard(clients_mutex);
    it = std::find(clients.begin(), clients.end(), socket.shared_from_this());
    if (it != clients.end())
      clients.erase(it);
  }

  void send_message(const Crails::WebSocket&amp; emitter, const std::string&amp; message)
  {
    std::lock_guard&lt;std::mutex&gt; guard(clients_mutex);

    for (WebSocketPtr client : clients)
    {
      if (client.get() != &amp;emitter)
        client-&gt;send(message, Crails::WebSocket::TextMessage);
    }
  }

private:
  std::mutex clients_mutex;
  Clients clients;
};
</code></pre>

<p>
  In this <code>ChatRoom</code> class, we use <code>std::mutex</code> to ensure thread-safety with our client list.
  In the <code>send_message</code> method, we loop over all our connected clients, and send a message to everyone
  except the WebSocket who emitted the message in the first place.
</p>

<p>
  Note that we used the <code>SINGLETON</code> macro, meaning we need to instantiate the singleton somwehere,
  ideally somewhere that won't be subjected to potential concurrency issues. We'll do it in our main function:
</p>

<pre class="filepath">app/main.cpp</pre>
<pre><code class="language-cpp">...
#include "controllers/chat_room.hpp"

int main()
{
  SingletonInstantiator&lt;ChatRoom&gt; chat_room; // just add this line to instantiate the singleton
  ...
}
</code></pre>

<p>
  Let's now write a new WebSocket class that will use this chatroom:
</p>

<pre class="filepath">app/controllers/chat_client.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include "chat_room.hpp"

class ChatClient : public Crails::WebSocket
{
  std::string nickname;
public:
  ChatClient(Crails::Context&amp; context) : Crails::WebSocket(context)
  {
    // First, we'll use the request parameters to let participants set a nickname
    nickname = context.params["nickname"].defaults_to&lt;std::string&gt;("anonymous");
  }

  // We need a method to handle the arrival of a new participant:
  void connect()
  {
    ChatRoom::singleton::get()-&gt;send_message(*this, "&lt;i&gt;" + nickname + " joined the room.&lt;/i&gt;");
    ChatRoom::singleton::get()-&gt;add_client(*this);
    read();
  }

  // Next, we need to broadcast received messages to the room
  void received(const std::string&amp; message, Crails::WebSocket::MessageType) override
  {
    ChatRoom::singleton::get()-&gt;send_message(*this, "&lt;b&gt;" + nickname + ":&lt;/b&gt; " + message);
    read();
  }

  // Finally, we remove the participant from the room when the socket gets disconnected
  void disconnected() const override
  {
    ChatRoom::singleton::get()-&gt;send_message(*this, "&lt;i&gt;" + nickname + " left the room.&lt;/i&gt;");
    ChatRoom::singleton::get()-&gt;remove_client(*this);
  }
};
</code></pre>

<p>
  Lastly, we add a route to reach our chatroom:
</p>

<pre class="filepath">app/routes.cpp</pre>
<pre><code class="language-cpp">#include &lt;crails/router.hpp&gt;
#include "app/controllers/home.hpp"
#include "app/controllers/echo_web_socket.hpp"
#include "app/controllers/chat_client.hpp" // add the ChatClient header

void Crails::Router::initialize(void)
{
  match_action("GET", "/", HomeController, homepage);
  match_websocket("/echo", EchoWebSocket, read);
  match_websocket("/chatroom/:nickname", ChatClient, connect); // add a new route
}
</code></pre>

<h2>3. WebSocket client with Comet</h2>

<p>
  We'll now take care of the client part. We'll design it using Comet.cpp. If you
  haven't used Comet yet, check out the <a href="../../comet/getting-started" target="_blank">Getting
  started with Comet</a> tutorial.
</p>

<p>
  Before all else, move to the client's directory at <code>app/client</code>: the <i>comet</i>
  command line interface should always run from this folder, or one of its descendents.
</p>

<pre>$ cd app/client</pre>

<h3>3.1 WebSocket</h3>

<p>
  Let's start with a chat room object: it will use a WebSocket to send and receive messages,
  and store the history of messages received. Create the following file:
</p>

<pre class="filepath">app/client/chat_room_client.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include &lt;comet/websocket.hpp&gt;

class ChatRoomClient
{
  std::unique_ptr&lt;Comet::WebSocket&gt; socket;
  std::string nickname;
  std::size_t maximum_history_size = 50;
  std::list&lt;std::string&gt; history;
public:
  Comet::Signal&lt;&gt; history_updated;

  const std::list&lt;std::string&gt;&amp; get_history() const { return history; }

  void connect(const std::string&amp; nickname_)
  {
    nickname = nickname_;
    socket.reset(new Comet::WebSocket("ws://localhost:3001/chatroom/" + nickname));
    socket-&gt;message_received.connect(std::bind(&amp;ChatRoom::add_message, this, std::placeholders::_1));
  }

  void add_message(const std::string&amp; message)
  {
    history.push_back(message);
    if (history.size() &gt; maximum_history_size)
      history.erase(history.begin());
    history_updated.trigger();
  }

  void send_message(const std::string&amp; message)
  {
    socket-&gt;send(message);
    add_message("&lt;b&gt;" + nickname + ": &lt;/b&gt;" + message);
  }
};
</code></pre>

<p>
  For receiving messages, the WebSocket object comes with a <code>message_received</code> signal,
  which we connect to the <code>add_message</code> method right after instantiating the WebSocket
  in the <code>connect</code> method.
</p>

<p>
  For sending messages, we use the <code>send</code> method, which takes <code>std::string</code>
  as its parameter, as seen in the <code>send_message</code> method.
</p>

<h3>3.2 Overloading WebSocket</h3>

<p>
  While it is possible to use <code>Comet::WebSocket</code> directly for simple use cases,
  if we want to handle other events from websockets, such as connection or disconnection,
  we will have to create a class that inherits <code>Comet::WebSocket</code> and overrides
  the <code>on_open</code>, <code>on_close</code>, <code>on_error</code> methods:
</p>

<pre class="filepath">app/client/chat_web_socket.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include &lt;comet/websocket.hpp&gt;

class ChatWebSocket : public Comet::WebSocket
{
public:
  Comet::Signal&lt;bool&gt; connection_changed;

  ChatWebSocket(Comet::String url) : Comet::WebSocket(url)
  {
  }

  void on_open(client::Event*) override
  {
    connection_changed.trigger(true);
  }

  void on_close(client::Event*) override
  {
    connection_changed.trigger(false);
  }

  void on_error(client::ErrorEvent*) override
  {
  }
};
</code></pre>

<p>
  In this example, we create a class that provides a <i>signal</i> when the state of the
  connection changed. Let's integrate this signal in our <code>ChatRoomClient</code> object:
</p>

<pre class="filepath">app/chat_room_client.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include "chat_web_socket.hpp"

class ChatRoomClient
{
  std::unique_ptr&lt;ChatWebSocket&gt; socket; // update the socket's classname
  std::string nickname;
  std::size_t maximum_history_size = 50;
  std::list&lt;std::string&gt; history;
public:
  Comet::Signal&lt;&gt; history_updated;

  const std::list&lt;std::string&gt;&amp; get_history() const { return history; }

  void connect(const std::string&amp; nickname_)
  {
    nickname = nickname_;
    socket.reset(new ChatWebSocket("ws://localhost:3001/chatroom/" + nickname));
    socket-&gt;message_received.connect(std::bind(&amp;ChatRoomClient::add_message, this, std::placeholders::_1));
    socket-&gt;connection_changed.connect(std::bind(&amp;ChatRoomClient::on_connection_changed, this, std::placeholders::_1));
  }

  void on_connection_changed(bool connected)
  {
    add_message(connected ? "You are now connected." : "You are not connected anymore.");
  }

  void add_message(const std::string&amp; message)
  {
    history.push_back(message);
    if (history.size() &gt; maximum_history_size)
      history.erase(history.begin());
    history_updated.trigger();
  }

  void send_message(const std::string&amp; message)
  {
    socket-&gt;send(message);
    add_message(nickname + ": " + message);
  }
};
</code></pre>

<p>
  By adding a listener for the <code>connection_changed</code> event, we will now display a message
  when the user connects or disconnects.
</p>

<h3>3.3 Chat room views</h3>

<h3>3.3.1 Connect view</h3>

<p>
  We've got the backend ready, let's move on to the frontend. We'll start by creating a connection room,
  where users can pick their nicknames. Run the following command in your <code>app/client</code> folder:
</p>

<pre>$ comet scaffold view -n ConnectView</pre>

<p>
  And update the generated <code>app/views/connect_view.html</code> file as following:
</p>

<pre class="filepath">app/client/views/connect_view.html</pre>
<pre><code class="language-html">&lt;template&gt;
  &lt;head&gt;
    &lt;script&gt;virtual void on_submit() = 0;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;form submit.trigger="on_submit()"&gt;
      &lt;div class="form-group"&gt;
        &lt;input type="text" class="form-control" ref="nickname_input" /&gt;
        &lt;input type="submit" class="btn btn-primary mb-3" /&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/template&gt;
</code></pre>

<p>
  This view has a text input that will be referenced as <code>nickname_input</code>, and declares
  the <code>on_submit</code> method, called when the form sends a <code>submit</code> event. The
  method needs an implementation, so let's add one in the view's header:
</p>

<pre class="filepath">app/client/views/connect_view.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include "templates/connect_view.hpp"

class ConnectView : public HtmlTemplate::ConnectView
{
public:
  Comet::Signal&lt;std::string&gt; accepted;

  void on_submit()
  {
    accepted.trigger(
      nickname_input.value&lt;std::string&gt;()
    );
  }
};
</code></pre>

<h3>3.3.2 Chatroom controller</h3>

<p>
  We'll now set up a controller to display the connection view, and eventually the chatroom.
  Run the following command:
</p>

<pre>$ comet scaffold controller -n ChatRoom</pre>

<p>
  Let us now add an <i>action</i> to that controller that will manage our connection view.
  Open the header at <code>app/client/controllers/chat_room.hpp</code>, and declare the
  <code>connect</code> method as such :
</p>

<pre class="filepath">app/controllers/chat_room.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include &lt;comet/mvc/controller.hpp&gt;

class ChatRoomController : public Comet::Controller
{
public:
  ChatRoomController(const Comet::Params&amp;);

  void connect();
};
</code></pre>

<p>
  Let's now implement it in the source file:
</p>

<pre class="filepath">app/client/controllers/chat_room.cpp</pre>
<pre><code class="language-cpp">#include "chat_room.hpp"
#include "../views/connect_view.hpp"

using namespace std;

unique_ptr&lt;ConnectView&gt; connect_view;

void ChatRoomController::connect()
{
  Comet::body.empty();
  connect_view.reset(new ConnectView);
  connect_view-&gt;append_to(Comet::body);
}

...
</code></pre>

<p>
  This will replace the content of the document's body with a freshly instantiated <code>ConnectView</code>.
  when the action is called. Let's add a route to the client router:
</p>

<pre class="filepath">app/client/routes.cpp</pre>
<pre><code class="language-cpp">#include &lt;comet/router.hpp&gt;
#include "controllers/chat_room.hpp"

void Comet::Router::initialize()
{
  match_action("/", ChatRoomController, connect);
}
</code></pre>

<h3>3.3.3 Connection</h3>

<p>
  Now that we have a form to enter our nickname, let's use it to implement connection with the <code>
  ChatRoom</code> object we created in <i>3.1</i>. Let's add a second route for connection:
</p>

<pre class="filepath">app/client/routes.cpp</pre>
<pre><code class="language-cpp">#include &lt;comet/router.hpp&gt;
#include "controllers/chat_room.hpp"

void Comet::Router::initialize()
{
  match_action("/", ChatRoomController, connect);
  match_action("/chatroom/:nickname", ChatRoomController, chatroom);
}
</code></pre>

<p>
  We'll add the <i>chatroom</i> action to our controller source:
</p>

<pre class="filepath">app/client/controllers/chat_room.cpp</pre>
<pre><code class="language-cpp">#include "chat_room.hpp"
#include "../views/connect_view.hpp"
#include "../chat_room_client.hpp"

using namespace std;

unique_ptr&lt;ChatRoomClient&gt; chatroom_client;
unique_ptr&lt;ConnectView&gt; connect_view;

void ChatRoomController::connect()
{
  Comet::body.empty();
  connect_view.reset(new ConnectView);
  connect_view-&gt;append_to(Comet::body);
}

void ChatRoomController::chatroom()
{
  chatroom_client.reset(new ChatRoomClient);
  chatroom_client-&gt;connect(params["nickname"]);
}
...
</code></pre>

<p>
  Let's also update the <code>connect</code> method so that submitting the form trigger the <i>chatroom</i>
  action:
</p>

<pre class="filepath">app/client/controllers/chat_room.cpp</pre>
<pre><code class="language-cpp">#include "../application.hpp"

...

void ChatRoomController::connect()
{
  Comet::body.empty();
  connect_view.reset(new ConnectView);
  connect_view-&gt;append_to(Comet::body);
  connect_view-&gt;accepted.connect([](const std::string&amp; nickname)
  {
    Application::get().router.navigate("/chatroom/" + nickname);
  });
}

...
</code></pre>

<h3>3.3.4 Chat view</h3>

<p>
  Last, but not least: the chat view. We'll be creating a view
  that displays the message history and input. Run the following command in your <code>app/client</code>
  directory:
</p>

<pre>$ comet scaffold view -n ChatRoomView -p 'std::vector&lt;std::string&gt;*/history'</pre>

<p>
  Open the generated file at <code>app/client/views/chat_room_view.html</code>, and modify it as
  following:
</p>

<pre class="filepath">app/client/views/chat_room_view.html</pre>
<pre><code class="language-html">&lt;template&gt;
  &lt;head&gt;
    &lt;attribute name="history" type="const std::list&lt;std::string&gt;*" value="nullptr" /&gt;
    &lt;script&gt;
      Comet::Signal&lt;std::string&gt; send_message;
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div repeat.for="line of [const std::list&lt;std::string&gt;]*history"&gt;
      &lt;span text.bind="line"&gt;&lt;/span&gt;
    &lt;/div&gt;
    &lt;form submit.trigger="send_message.trigger(message_input.value&lt;std::string&gt;())"&gt;
      &lt;div class="input-group"&gt;
        &lt;input type="text" class="form-control" ref="message_input" /&gt;
        &lt;input type="submit" class="btn btn-primary mb-3" /&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/template&gt;
</code></pre>

<p>
  This view consists of two parts: the first one is a <i>repeater</i>, which will repeat
  the &lt;div&gt; element for each line in the history. The second one is a form, much like
  the one we've seen in the connection view.
</p>

<p>
  We're nearly done. We have to render the chat view from the <code>chatroom</code> action we've
  created earlier. Open <code>app/client/controllers/chat_room.hpp</code> and update the <code>chatroom</code>
  method as such:
</p>

<pre class="filepath">app/client/controllers/chat_room.cpp</pre>
<pre><code class="language-cpp">#include "../views/chat_room_view.hpp"

...
unique_ptr&lt;ChatRoomView&gt; chatroom_view;
...

void ChatRoomController::chatroom()
{
  Comet::body.empty();
  chatroom_view.reset(new ChatRoomView);
  chatroom_client.reset(new ChatRoomClient);
  chatroom_client-&gt;history_updated.connect(
    std::bind(&amp;ChatRoomView::trigger_binding_updates, chatroom_view.get())
  );
  chatroom_view-&gt;send_message.connect([](const std::string&amp; message)
  {
    chatroom_client-&gt;send_message(message);
  });
  chatroom_view-&gt;set_history(&amp;chatroom_client-&gt;get_history());
  chatroom_client-&gt;connect(params["nickname"]);
  chatroom_view-&gt;bind_attributes();
  chatroom_view-&gt;append_to(Comet::body);
}
</code></pre>

<p>
  And this is it: the history attribute from the view is now a pointer to the history in
  our <code>ChatRoomClient</code> object, and the view bindings will all update
  whenever the <code>history_updated</code> signal is sent.<br>
  On the other side, when the <code>send_message</code> signal gets called on the view,
  it will call <code>send_message</code> on the <code>ChatRoomClient</code> object, and
  it will clear the message input.
</p>

<p>
  All done. Now, build, launch the server, and profit:
</p>

<pre>$ crails build
$ build/server</pre>

      </div>
    </div>
    <div id="footer">
      This work is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>
      It is a modified version of the <a href="https://guides.rubyonrails.org/">Ruby on Rails guides</a>, amended and completed to fit Crails development.
    </div>
    <script>hljs.initHighlightingOnLoad();</script>
  

</body></html>