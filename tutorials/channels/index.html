<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <title>Crails Framework - Channels and message broadcasting</title>
    <link rel="stylesheet" href="../../css/application.css">
    <link rel="stylesheet" href="../../css/code-qtcreator.css">
    <script src="../../highlight.pack.js"></script>
    <script src="../../js/index.js"></script>

    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="Nanoc 4.12.7">
  </head>
  <body>
    <div id="header">
      <img class="logo" src="../../images/logo.png">
      <h1>Crails Framework</h1>
      <ul class="main-menu">
        <li><a href="../../">Home</a></li><li>
            <a href="../../getting-started">Getting started</a></li><li>
            <a href="..">Tutorials</a></li><li>
	    <a href="https://github.com/crails-framework/crails" target="_blank">GitHub</a></li>
      </ul>
    </div>
    <div id="content-wrapper">
      <div id="main">
        <div id="with-index"></div>

<h2>1. Introduction</h2>

<p>
  In the following tutorial, we'll learn how to use the <b>sync</b> plugin to create a simple chat-room application.<br>
  You could achieve a similar result using plain <i>WebSockets</i> (see the <a href="../websockets">WebSocket tutorial</a>).
  But in this tutorial, we'll take a different approach, and use Crails' <i>Channels</i>.
</p>

<p>
  Channels are based on WebSocket, and allow both the server and each client to broadcast messages to both the server
  and every other connected client. The read/write access of each channel can also be restricted depending on the user.
  Sounds perfect for a chat application ! Let's dive in !
</p>

<h3>1.1 Preparations</h3>

<p>
  Create the <code>chatnnel</code> application with the following command:
</p>

<pre>$ crails new -n chatnnel -p html
cd chatnnel</pre>

<p>
  Then add the <code>sync</code> plugin to the application:
</p>

<pre>$ crails plugins sync install</pre>

<h2>2. Public chatroom</h2>

<h3>2.1 HTML</h3>

<p>
  We'll start by creating a simple view to render our chatroom.
</p>

<pre class="filepath">app/views/chatroom.html</pre>
<pre><code class="language-html">std::string @room_id;
// END LINKING
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Chatnell room - &lt;%= room_id %&gt;&lt;/title&gt;
  &lt;/head&gt;
  &lt;body data-room-id=""&gt;
    &lt;h1&gt;Chatnnel room&lt;/h1&gt;
    &lt;h2&gt;&lt;%= room_id %&gt;&lt;/h2&gt;

    &lt;textarea placeholder="Write your message..."&gt;&lt;/textarea&gt;
    &lt;button id="send-button"&gt;Send&lt;/button&gt;

    &lt;table&gt;
      &lt;tbody id="message-container"&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>
  Pretty simple stuff: a textarea to input text, and a table to display the message received.
</p>

<p>
  We also declared a <code>room_id</code> shared property: that's because we are going to allow
  the application to host as many rooms as the user may create.
</p>

<h3>2.2 JavaScript</h3>

<p>
  We also need some JavaScript to connect to the channel and update the message list. This is achieved
  using <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank">WebSockets</a>.
  Open our html view again and add the following javascript below the &lt;table&gt; element:
</p>

<pre class="filepath">app/views/chatroom.html</pre>
<pre><code class="language-html">    &lt;script&gt;
      const socket = new WebSocket("ws://localhost:3001/chatroom/&lt;%= room_id %&gt;/channel");
      socket.onmessage = function(event) {
        const list = document.querySelector("#message-container");
        const row = document.createElement("tr");
        const messageCell = document.createElement("td");
        messageCell.textContent = event.data;
        row.appendChild(messageCell);
        list.prepend(row);
      };

      document.querySelector("#send-button").addEventListener("click", function() {
        const input = document.querySelector("textarea");
        const message = input.value;
        socket.send(message);
        input.value = "";
      });
    &lt;/script&gt;
</code></pre>

<p>
  Simple stuff again: we connect a chatroom to the <code>/chatroom/:room_id/channel</code> UID, which
  we will bind later in our application's router. When the user press the button, we send the textarea
  content to the WebSocket, and when the WebSocket sends us a message, we add a new row to <i>#message-container</i>
  displaying the received message.
</p>

<div class="hint-box">
  Messages sent to a channel are broadcasted to every connected client, including the one who sent
  the message. Hence why we don't need to append the message in the button <code>click</code> event handler: it will
  be appended when it comes back through the WebSocket's <code>message</code> event handler.
</div>

<h3>2.2 Controller</h3>

<p>
  At this point, the chatroom client is almost ready: we just need a simple controller to render the HTML we
  created earlier. Generate a basic controller using the following command:
</p>

<pre>$ crails scaffold controller -n chatroom</pre>

<p>
  Then declare a <code>show</code> action method:
</p>

<pre class="filepath">app/controllers/chatroom.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include "app/controllers/application.hpp"

class ChatroomController : public ApplicationController
{
public:
  ...

  // Declare the show action:
  void show();
};
</code></pre>

<p>
  And add the corresponding implementation in the controller source file:
</p>

<pre class="filepath">app/controllers/chatroom.cpp</pre>
<pre><code class="language-cpp">#include "chatroom.hpp"
#include &lt;crails/params.hpp&gt;

...

void ChatroomController::show()
{
  render("chatroom", {
    {"room_id", params["room_id"].as&lt;std::string&gt;()}
  });
}
</code></pre>

<h3>2.3 Router</h3>

<p>
  Lastly, we need to two routes to our router: one to serve the chatroom html,
  the other to serve as the endpoint for the client's WebSockets:
</p>

<pre class="filepath">app/routes.cpp</pre>
<pre><code class="language-cpp">#include &lt;crails/router.hpp&gt;
#include &lt;crails/sync/channel_actions.hpp&gt; // header for channel routes
#include "controllers/chatroom.hpp" // our controller

void Crails::Router::initialize()
{
  match_action("GET", "/chatroom/:room_id", ChatroomController, show);
  match_sync_channel("/chatroom/:room_id/channel", Crails::Sync::ChannelClient);
}
</code></pre>

<p>
  And we're done ! Build and start the server, then go at <a href="http://localhost:3001/chatroom/test-room" target="_blank">http://localhost:3001/chatroom/test-room</a> to try it out !
</p>

<h2>3. Idenitfy clients</h2>

<p>
  In our current implementations, messages are broadcasted to each client, but there are no way to tell who emitted which messages. In this chapter,
  we'll update our chatroom application so that each client is identified with a username.
</p>

<h2>4. Private chatroom</h2>

<p>
  All our chatrooms are publicly accessible. But what if you want your channels to be only accessible to some users ? Channels can be protected
  so that users cannot read or/and write, using passwords.
</p>

      </div>
    </div>
    <div id="footer">
      This work is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>
      It is a modified version of the <a href="https://guides.rubyonrails.org/">Ruby on Rails guides</a>, amended and completed to fit Crails development.
    </div>
    <script>hljs.initHighlightingOnLoad();</script>
  

</body></html>