<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <title>Crails Framework - Testing your Application</title>
    <link rel="stylesheet" href="../../css/application.css">
    <link rel="stylesheet" href="../../css/code-qtcreator.css">
    <script src="../../highlight.pack.js"></script>
    <script src="../../js/index.js"></script>

    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="Nanoc 4.12.11">
  </head>
  <body>
    <div id="header">
      <img class="logo" src="../../images/logo.png">
      <h1>Crails Framework</h1>
      <ul class="main-menu">
        <li><a href="../../">Home</a></li><li>
            <a href="../../getting-started">Getting started</a></li><li>
            <a href="..">Tutorials</a></li><li>
	    <a href="https://github.com/crails-framework/crails" target="_blank">GitHub</a></li>
      </ul>
    </div>
    <div id="content-wrapper">
      <div id="main">
        <div id="with-index"></div>

<h2>1. Introduction</h2>

<p>
  Testing is an important part of your applications, so Crails comes with
  tools to help you run all sorts of tests.
</p>

<h2>2. Writing tests</h2>

<h3>2.1 Adding a new test</h3>

<p>
  The crails CLI tool comes with a scaffold for tests. Run the following command:
</p>

<pre>$ crails scaffold test --name MySpec</pre>

<p>
  This will generate a new <code>MySpec</code> class. Open up the source file:
</p>

<pre class="filepath">spec/my_spec.cpp</pre>
<pre><code class="language-cpp">#include "my_spec.hpp"

MySpec::MySpec()
{
  before(std::bind(&amp;MySpec::before_all, this));
  after(std::bind(&amp;MySpec::after_all, this));

  describe("name of a method", [this]()
  {
    it("fails", [this]()
    {
      EXPECT(1, ==, 2);
    });
  });
}

void MySpec::before_all()
{
}

void MySpec::after_all()
{
}
</code></pre>

<p>
  Tests are reparted in categories defined with the <code>describe</code> method. Then,
  each test unit is defined using the <code>it</code> method, typically followed with
  a short sentence describing the expectation of the test, such as:
  <code>it("should succeed", callback)</code>.
</p>

<p>
  The <code>EXPECT</code> macro is used to define the success conditions of a test. A test
  may contain any number of call to <code>EXPECT</code>, or none at all: another way to fail
  a test can be to throw an exception.
</p>

<p>
  Next step. we need to register the test in the runner:
</p>

<pre class="filepath">spec/spec.cpp</pre>
<pre><code class="language-cpp">#include &lt;crails/tests/runner.hpp&gt;
#include "my_spec.hpp"

using namespace std;

void Crails::Tests::Runner::setup()
{
  helpers.push_back(make_shared&lt;MySpec&gt;());
}

void Crails::Tests::Runner::shutdown()
{
}
</code></pre>

<p>
  Our test is ready to fail with success. Run the following command:
</p>

<pre>$ crails build
$ build/tests</pre>

<h3>2.2 Request tests</h3>

<p>
  Crails provide a simple way to write request tests, in which you simulate
  an HTTP query and analyze its response. Let's update our previous test to
  run a test request:
</p>

<pre class="filepath">spec/my_spec.hpp</pre>
<pre><code class="language-cpp">#include &lt;crails/tests/helper.hpp&gt;
#include &lt;crails/tests/request.hpp&gt;

class MySpec : public Crails::Tests::Helper
{
  MySpec()
  {
    using namespace Crails;
    describe("index", []()
    {
      it("lists items", []()
      {
        Tests::Request request(HttpVerb::get, "/route");

        request.run();
        EXPECT_STATUS(request, HttpStatus::not_found); 
      });
    });
  }
};
</code></pre>

<p>
  If you run the test right now, you'll see an exception thrown, warning you
  that the <code>Router</code> is not initialized. The router needs to be
  initialized and finalized as the test suite runs and stops:
</p>

<pre class="filepath">spec/spec.cpp</pre>
<pre><code class="language-cpp">#include &lt;crails/tests/runner.hpp&gt;
#include &lt;crails/router.hpp&gt;
#include "my_spec.hpp"

using namespace std;

void Crails::Tests::Runner::setup()
{
  Crails::Router::singleton::initialize();
  Crails::Router::singleton::get()-&gt;initialize();
  helpers.push_back(make_shared&lt;MySpec&gt;());
}

void Crails::Tests::Runner::shutdown()
{
  Crails::Router::singleton::finalize();
}
</code></pre>

<p>
  Our test should now pass: build and run the test suite:
</p>

<pre>$ crails build
$ build/tests</pre>

<h4>2.2.1 Injecting params in a request</h4>

<p>
  Instead of building fully-fledged http requests for your tests, you may
  want to bypass that step and directly inject values into the context's
  <a href="https://crails-framework.github.io/api-reference/#/packages/libcrails/classes/::Crails::Params" target="_blank">params</a>
  object.
</p>

<p>
  In the following exemple, we will use <code>Test::Request</code>'s params
  attribute to inject the parameters of a search query:
</p>

<pre class="filepath">spec/my_spec</pre>
<pre><code class="language-cpp">#include &lt;crails/tests/helper.hpp&gt;
#include &lt;crails/tests/request.hpp&gt;

class MySpec : public Crails::Tests::Helper
{
  MySpec()
  {
    using namespace Crails;
    describe("index", []()
    {
      it("lists items", []()
      {
        Tests::Request request(HttpVerb::post, "/search-song");
        DataTree response;

        request.params["title"]  = "Conscious Club";
        request.params["year"]   = 2016;
        request.run();
        EXPECT_STATUS(request, HttpStatus::ok);
        response.from_json(request.response.body());
        EXPECT(response["artist"].as&lt;string&gt;(), ==, "Vulfpeck");
        EXPECT(response["album"].as&lt;string&gt;(),  ==, "Conscious Club");
        EXPECT(response["track"].as&lt;int&gt;(),     ==, 4);
      });
    });
  }
};
</code></pre>

<h4>2.2.2 Session parameters</h4>

<p>
  You may also inject your own session variables into a request in a
  similar fashion:
</p>

<pre class="filepath">spec/my_spec.cpp</pre>
<pre><code class="language-cpp">#include &lt;crails/tests/helper.hpp&gt;
#include &lt;crails/tests/request.hpp&gt;

class MySpec : public Crails::Tests::Helper
{
  MySpec()
  {
    using namespace Crails;
    describe("index", []()
    {
      it("lists items", []()
      {
        Tests::Request request(HttpVerb::get, "/private");

        request.session["current_user_id"] = 1;
        request.run();
        EXPECT_STATUS(request, HttpStatus::ok);
      });
    });
  }
};
</code></pre>

<p>
  With session variables though, you may also be interested in the
  state of the session after the request completed. For instance,
  to check if an user has properly been disconnected:
</p>

<pre class="filepath">spec/my_spec.cpp</pre>
<pre><code class="language-cpp">#include &lt;crails/tests/helper.hpp&gt;
#include &lt;crails/tests/request.hpp&gt;

class MySpec : public Crails::Tests::Helper
{
  MySpec()
  {
    using namespace Crails;
    describe("index", []()
    {
      it("lists items", []()
      {
        Tests::Request request(HttpVerb::post, "/disconnect");

        request.session["current_user_id"] = 1;
        request.run();
        EXPECT_STATUS(request, HttpStatus::ok);
        EXPECT(request.session["current_session_id"].exists(), !=, true);
      });
    });
  }
};
</code></pre>

<h3>2.3 Test preparation</h3>

<p>
  You might want to run code before and after each tests. The <code>after</code> and <code>before</code>
  methods cam help you define such behaviors for each test group:
</p>

<pre class="filepath">spec/my_spec.hpp</pre>
<pre><code class="language-cpp">#include &lt;crails/tests/helper.hpp&gt;
#include &lt;crails/tests/request.hpp&gt;

class MySpec : public Crails::Tests::Helper
{
  MySpec()
  {
    using namespace Crails;
    before([this]()
    {
      std::cout &lt;&lt; "before each tests" &lt;&lt; std::endl;
    });

    after([this]()
    {
      std::cout &lt;&lt; "after each tests" &lt;&lt; std::endl;
    });

    describe("index", [this]()
    {
      before([this]()
      {
        std::cout &lt;&lt; "before each index tests" &lt;&lt; std::endl;
      });

      after([this]()
      {
        std::cout &lt;&lt; "after each index tests" &lt;&lt; std::endl;
      });

      it("lists items", [this]()
      {
        Tests::Request request(HttpVerb::get, "/route");

        request.run();
        EXPECT_STATUS(request, HttpStatus::not_found); 
      });
    });
  }
};
</code></pre>

<h2>3. End-to-end testing</h2>

<p>
  You may want to go deeper, and write tests that inspect the
  web pages rendered by your application. To perform end-to-end
  testing, we use the <code>libcrails-selenium</code> module.
</p>

<p>
  Install the selenium plugin with the following command:
</p>

<pre>$ crails plugin selenium install</pre>

<p>
  This command will download the selenium driver, and include
  new helpers for your tests.
</p>

<h3>3.1 Configure a background server</h3>

<p>
  For end-to-end testing to work, we need a server to run in the
  background, available for our headless browser to interact with it.
</p>

<p>
  Update the <code>spec.cpp</code> file to use the <code>Crails::Tests::BackgroundServer</code> singleton:
</p>

<pre class="filepath">spec/spec.cpp</pre>
<pre><code class="language-cpp">#include &lt;crails/tests/runner.hpp&gt;
#include "my_spec.hpp"
#include &lt;crails/tests/background_server.hpp&gt;

using namespace std;

void Crails::Tests::Runner::setup()
{
  Crails::Tests::BackgroundServer::initialize();
  helpers.push_back(make_shared&lt;MySpec&gt;());
}

void Crails::Tests::Runner::shutdown()
{
  Crails::Tests::BackgroundServer::finalize();
}
</code></pre>

<h3>3.2 Writing an end-to-end test</h3>

<p>
  End-to-end test helpers should inherit from <code>Crails::Tests::SeleniumHelper</code>. A browser will
  be launched each time such a helper is triggered, and you will have access to new methods within the
  helper to interact with the browser. Before we take a look at that, update our spec header to include
  <code>Crails::Tests::SeleniumHelper</code>:
</p>

<pre class="filepath">spec/my_spec.hpp</pre>
<pre><code class="language-cpp">#pragma once
#include &lt;crails/tests/helper.hpp&gt;
#include &lt;crails/tests/selenium_helper.hpp&gt;

class MySpec : public Crails::Tests::SeleniumHelper
{
public:
  MySpec();

private:
  void before_all();
  void after_all();
};
</code></pre>

<p>
  We're now ready to update our test so that it tests a page in the browser:
</p>

<pre class="filepath">spec/my_spec.cpp</pre>
<pre><code class="language-cpp">#include "my_spec.hpp"

MySpec::MySpec()
{
  before(std::bind(&amp;MySpec::before_all, this));
  after(std::bind(&amp;MySpec::after_all, this));

  describe("name of a method", [this]()
  {
    it("fails", [this]()
    {
      page-&gt;visit("/");
      page-&gt;expect()
        .to_have_element("body &gt; h1")
        .with_content("Welcome to your new Crails Application");
    });
  });
}

void MySpec::before_all()
{
}

void MySpec::after_all()
{
}
</code></pre>

<p>
  As you can see on this example, you have no access to a <code>page</code> property, which allows you to
  interact with the test browser loaded by Selenium. We use the <code>page-&gt;visit</code> method to
  load a given URI to the browser.
</p>

<p>
  The <code>page</code> controller also gives you access to a new expectation system. You can still use
  the <code>EXPECT</code> macro, but selenium based expectation will allow you to navigate within the DOM
  of your generated page, check for the presence of elements, their contents, and such.
</p>

<h3>3.3 Interacting with page elements</h3>

<p>
  The <code>libcrails-selenium</code> plugin leverages the <a href="https://github.com/crails-framework/webdriverxx" target="_blank">webdriverxx</a>
  library: its README will tell you all you need to know about it.
</p>

<p>
  To setup your test, you'll need to interact with page elements. You can get a handle on elements
  using the <code>page-&gt;find</code> method, using a selector string:
</p>

<pre><code class="language-cpp">webdriverxx::Element element = page-&gt;find("input[type=\"text\"]");

element.SendKeys("Hello, world !");
page-&gt;find("input[type\"submit\"]").Click();
</code></pre>

      </div>
    </div>
    <div id="footer">
      This work is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>
      It is a modified version of the <a href="https://guides.rubyonrails.org/">Ruby on Rails guides</a>, amended and completed to fit Crails development.
    </div>
    <script>hljs.initHighlightingOnLoad();</script>
  

</body></html>